<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决Mac上Office提示身份验证会话已过期。请再次登录]]></title>
    <url>%2F2019%2F06%2F13%2F%E8%A7%A3%E5%86%B3Mac%E4%B8%8AOffice%E6%8F%90%E7%A4%BA%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%BC%9A%E8%AF%9D%E5%B7%B2%E8%BF%87%E6%9C%9F%E3%80%82%E8%AF%B7%E5%86%8D%E6%AC%A1%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>我的软件</tag>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse开启代码补全]]></title>
    <url>%2F2019%2F06%2F04%2FEclipse%E5%BC%80%E5%90%AF%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%2F</url>
    <content type="text"><![CDATA[eclipse代码提示Preferences-&gt;Java-&gt;Editor-&gt;content assist 在第二项中的”.”后边追加”abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVW” 如图： 变量自动提示（关键）Preferences-&gt;Java-&gt;Editor-&gt;content assist-&gt;Advnced 将需要的提示类型全部勾选 如图： 只开启这个选项也可以，通过option + / 实现提示。 取消“=”等号和空格自动输入开启第一步的增强提示后，必须键入Esc才不会自动补全你的变量，如果你键入的是空格或者“=”，那么变量名就会被自动补全。 新版本解决方案 Preferences -&gt; Java -&gt; Editor -&gt; Content Assist 勾选Disable insertion triggers except ‘Enter’选项，即只有按enter键时才触发自动补全功能。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>我的软件</tag>
        <tag>Mac OS</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的Python程序跑在服务器后台]]></title>
    <url>%2F2019%2F06%2F04%2F%E8%AE%A9%E4%BD%A0%E7%9A%84Python%E7%A8%8B%E5%BA%8F%E8%B7%91%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[前情提要最近买了一个月的阿里云的轻量应用服务器，当然要好好利用一下，耍一耍，所以第一站Python脚本跑一跑。 Python脚本的部署大家都知道命令后加一个”&amp;”, 可以让bash跑在后台中。但是这个时候，我们断掉ssh会发现，程序也就中断了。所以我们需要其他方法1nohup python -u robot.py &gt; robot.log 2&gt;&amp;1 &amp; 让我们看看这个命令完成了什么样的操作： nohup的作用：当终端结束后允许程序继续存活。 python robot.py 即运行一个py程序。 -u 就是指定实时的日志输出目录。 robot.log 就是我们的日志输出文件 2&gt;&amp;1 在下文中详细描述。 &amp; 符号是使程序在后台运行。 bash中 2&gt;&amp;1 bash中0，1，2三个数字分别代表STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，即标准输入（一般是键盘），标准输出（一般是显示屏，准确的说是用户终端控制台），标准错误（出错信息输出）。 输入输出可以重定向，所谓重定向输入就是在命令中指定具体的输入来源，譬如 cat &lt; test.c 将test.c重定向为cat命令的输入源。输出重定向是指定具体的输出目标以替换默认的标准输出，譬如ls &gt; 1.txt将ls的结果从标准输出重定向为1.txt文本。有时候会看到如 ls &gt;&gt; 1.txt这类的写法，&gt; 和 &gt;&gt; 的区别在于：&gt; 用于新建而&gt;&gt;用于追加。即ls &gt; 1.txt会新建一个1.txt文件并且将ls的内容输出到新建的1.txt中，而ls &gt;&gt; 1.txt则用在1.txt已经存在，而我们只是想将ls的内容追加到1.txt文本中的时候。 默认输入只有一个（0，STDIN_FILENO），而默认输出有两个（标准输出1 STDOUT_FILENO，标准错误2 STDERR_FILENO）。因此默认情况下，shell输出的错误信息会被输出到2，而普通输出信息会输出到1。 在一个终端下看到所有的信息（包括标准输出信息和错误信息），利用输出重定向。2&gt;&amp;1就是用来将标准错误2重定向到标准输出1中的。此处1前面的&amp;就是为了让bash将1解释成标准输出而不是文件1。 停止Python程序12ps -ef | grep pythonkill -9 PID]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>我的软件</tag>
        <tag>Python</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew的使用]]></title>
    <url>%2F2019%2F05%2F30%2FHomebrew%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[查看brew的帮助brew -help 安装软件brew install software_name 卸载软件brew uninstall software_name 搜索软件brew search software_name 显示已安装的软件列表brew list 更新brew软件brew update [software_name] 升级软件brew upgrade [software_name] 删除软件brew cleanup [software_name] 查看需要更新的软件brew outdated 查看安装选项brew options software_name 查看软件信息brew info software_name 显示包依赖brew deps software_name 用浏览器打开主页brew home software_name]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Mac OS</tag>
        <tag>Terminal</tag>
        <tag>Homebrew</tag>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的Ubuntu更好用]]></title>
    <url>%2F2019%2F05%2F29%2F%E8%AE%A9%E4%BD%A0%E7%9A%84Ubuntu%E6%9B%B4%E5%A5%BD%E7%94%A8%2F</url>
    <content type="text"><![CDATA[输入法 移除旧输入法 123sudo apt-get remove ibus scim // 卸载ibussudo apt-get autoremove // 删除依赖包sudo apt-get -f install // 修正安装过程中出现的依赖性关系 安装fcitx 1sudo apt-get install fcitx 配置fcitx设置 &gt; 区域和语言 &gt; 管理已安装的语言 &gt; 键盘输入法系统 choose fcitx &gt; 应用到全局 &gt; 重启Ubuntu 下载安装搜狗输入法在官网上下载安装包 https://pinyin.sogou.com/linux/ ,然后点击安装。或者 12sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.debsudo apt-get install -f //修复损坏的包 配置输入法Fcitx设置 &gt; 输入法 &gt; 添加搜狗拼音 解决shift切换快捷键冲突的问题Fcitx设置 &gt; 全局设置 输入法皮肤透明fcitx设置 &gt; 附加组件&gt; 勾选高级 &gt; 取消经典界面 换源软件和更新 &gt; 选择下载服务器 &gt; choose aliyun 美化美化软件12//优化sudo apt-get install gnome-tweak-tool 风格：https://github.com/vinceliuice/vimix-gtk-themes 图标：https://github.com/vinceliuice/vimix-icon-theme 也可以访问 https://vinceliuice.github.io/ 获取更多风格样式 使用方法： 下载releases 包 解包并执行 ./install.sh1tar zxvf vimix-gtk-themes-2019-05-03.tar.gz 在安装的优化软件中选择安装的风格和图标：]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>换源</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习SpringMVC - day3]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%AD%A6%E4%B9%A0SpringMVC-day3%2F</url>
    <content type="text"><![CDATA[包装类型参数绑定将pojo对象作为一个包装对象的属性，action中以该包装对象作为形参。 包装类1234567public class ItemsQueryVo &#123; // 商品信息 private Items items; // 为了系统 可扩展性，对原始生成的po进行扩展 private ItemsCustom itemsCustom; jsp页面1&lt;td&gt;商品名称： &lt;input name="itemsCustom.name" /&gt;&lt;/td&gt; itemsCustom和包装pojo中的属性一致即可。 controller方法12345@RequestMapping("/queryItems")public ModelAndView queryItems(HttpServletRequest request, ItemsQueryVo itemsQueryVo) throws Exception &#123; // 调用service查找 数据库，查询商品列表 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(itemsQueryVo); 集合类型绑定数组将页面选择(多选)的商品id，传到controller方法的形参，方法形参使用数组接收页面请求的多个商品id。 controller12@RequestMapping("/deleteItems")public String deleteItems(Integer[] items_id) throws Exception &#123; jsp页面12345678910111213&lt;c:forEach items="$&#123;itemsList&#125;" var="item"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" name="items_id" value="$&#123;item.id&#125;" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/items/editItems.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; List需要批量提交数据时，将提交的数据绑定到list&lt;pojo&gt; 包装类12345678910// 批量商品信息private List&lt;ItemsCustom&gt; itemsList;public List&lt;ItemsCustom&gt; getItemsList() &#123; return itemsList;&#125;public void setItemsList(List&lt;ItemsCustom&gt; itemsList) &#123; this.itemsList = itemsList;&#125; controller123// 通过ItemsQueryVo接收批量提交的商品信息，将商品信息存储到itemsQueryVo中itemsList属性中。@RequestMapping("/editItemsAllSubmit")public String editItemsAllSubmit(ItemsQueryVo itemsQueryVo) throws Exception &#123; jsp页面12345678&lt;c:forEach items=&quot;$&#123;itemsList &#125;&quot; var=&quot;item&quot; varStatus=&quot;status&quot;&gt;&lt;tr&gt; &lt;td&gt;&lt;input name=&quot;itemsList[$&#123;status.index &#125;].name&quot; value=&quot;$&#123;item.name &#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;itemsList[$&#123;status.index &#125;].price&quot; value=&quot;$&#123;item.price &#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;itemsList[$&#123;status.index &#125;].createtime&quot; value=&quot;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;itemsList[$&#123;status.index &#125;].detail&quot; value=&quot;$&#123;item.detail &#125;&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt; ${itemsList} 介绍：modelAndView.addObject(“itemsList”, itemsList);// 相当于request的setAttribut，在jsp页面中通过itemsList取数据 input的name属性介绍：itemsList 对应包装类型pojo中的list属性名status.index 下标从零开始.name,.price 对应包装类型pojo中的list类型的属性中的pojo的属性名 Map在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收。 包装类：1234Public class QueryVo &#123; private Map&lt;String, Object&gt; itemInfo = new HashMap&lt;String, Object&gt;(); //get/set方法..&#125; jsp页面：1234567&lt;tr&gt;&lt;td&gt;学生信息：&lt;/td&gt;&lt;td&gt;姓名：&lt;inputtype="text"name="itemInfo['name']"/&gt;年龄：&lt;inputtype="text"name="itemInfo['price']"/&gt;&lt;/td&gt;&lt;/tr&gt; controller123public String useraddsubmit(Model model,QueryVo queryVo)throws Exception&#123; System.out.println(queryVo.getStudentinfo());&#125; ###自定义参数绑定 自定义converter(转换器)1234567891011121314151617181920212223242526272829package ccut.rj.springmvc_mybatis.controller.converter;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.core.convert.converter.Converter;public class CustomDateConverter implements Converter&lt;String,Date&gt;&#123; @Override public Date convert(String source) &#123; //实现 将日期串转成日期类型(格式是yyyy-MM-dd HH:mm:ss) SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); try &#123; //转成直接返回 return simpleDateFormat.parse(source); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //如果参数绑定失败返回null return null; &#125;&#125; 配置方法 1234567891011121314&lt;mvc:annotation-driven conversion-service="conversionService"/&gt;&lt;!-- 自定义参数绑定 --&gt; &lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;!-- 转换器 --&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;!-- 日期类型转换 --&gt; &lt;bean class="ccut.rj.springmvc_mybatis.controller.converter.CustomDateConverter" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 123456789101112131415161718192021&lt;!--注解适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="webBindingInitializer" ref="customBinder"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 自定义webBinder --&gt;&lt;bean id="customBinder" class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer"&gt; &lt;property name="conversionService" ref="conversionService" /&gt;&lt;/bean&gt;&lt;!-- conversionService --&gt;&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;!-- 转换器 --&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="ccut.rj.springmvc_mybatis.controller.converter.CustomDateConverter"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; springmvc校验通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。 服务端校验控制层conroller：校验页面请求的参数的合法性。在服务端控制层conroller校验，不区分客户端类型（浏览器、手机客户端、远程调用） 业务层service（使用较多）：主要校验关键业务参数，仅限于service接口中使用的参数。 持久层dao：一般是不校验的。 springmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。 校验思路：页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面。 具体需求：商品修改，添加校验（校验商品名称长度，生产日期的非空校验），如果校验出错，在商品修改页面显示错误信息。 jar包导入 hibernate-validation jboss-logging validation-api 配置validator1234567891011121314151617181920212223&lt;!-- 校验器 --&gt; &lt;bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"&gt; &lt;!-- hibernate校验器 --&gt; &lt;property name="providerClass" value="org.hibernate.validator.HibernateValidator" /&gt; &lt;!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下的ValidationMessages.properties --&gt; &lt;property name="validationMessageSource" ref="messageSource" /&gt; &lt;/bean&gt; &lt;!-- 校验错误信息配置文件 --&gt; &lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt; &lt;!-- 资源文件名 --&gt; &lt;property name="basenames"&gt; &lt;list&gt; &lt;value&gt;classpath:CustomValidationMessages&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name="fileEncodings" value="utf-8" /&gt; &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt; &lt;property name="cacheSeconds" value="120" /&gt; &lt;/bean&gt; 将validator加到处理器适配器12&lt;mvc:annotation-driven conversion-service="conversionService" validator="validator" /&gt; 1234567891011&lt;!-- 自定义webBinder --&gt; &lt;bean id="customBinder" class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer"&gt; &lt;property name="validator" ref="validator" /&gt; &lt;/bean&gt;&lt;!-- 注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="webBindingInitializer" ref="customBinder"&gt;&lt;/property&gt; &lt;/bean&gt; 添加规则验证1234567public class Items &#123; private Integer id; @Size(min=1,max=30,message="&#123;item.name.length.error&#125;") private String name; @NotEmpty(message="&#123;pic.is.null&#125;") private String pic; CustomValidationMessages.properties123#\u6dfb\u52a0\u6821\u9a8c\u9519\u8bef\u63d0\u4ea4\u4fe1\u606fitems.name.length.error=\u8bf7\u8f93\u51651\u523030\u4e2a\u5b57\u7b26\u7684\u5546\u54c1\u540d\u79f0items.createtime.isNUll=\u8bf7\u8f93\u5165 \u5546\u54c1\u7684\u751f\u4ea7\u65e5\u671f 捕获校验错误信息在需要校验的pojo前边添加@Validated，在需要校验的pojo后边添加BindingResult bindingResult接收校验出错信息ps：@Validated和BindingResult bindingResult是配对出现，并且形参顺序是固定的（一前一后）。 在页面显示校验错误信息controller12345678910111213141516171819202122232425262728293031323334@RequestMapping("/editItemsSubmit") public String editItemsSubmit( Model model, HttpServletRequest request, Integer id, @Validated ItemsCustom itemsCustom, BindingResult bindingResult ) throws Exception &#123; // 获取校验错误信息 if (bindingResult.hasErrors()) &#123; // 输出错误信息 List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors(); for (ObjectError objectError : allErrors) &#123; // 输出错误信息 System.out.println(objectError.getDefaultMessage()); &#125; // 将错误信息传到页面 model.addAttribute("allErrors", allErrors); //数据回显 model.addAttribute("itemsCustom", itemsCustom); // 出错重新到商品修改页面 return "items/editItems"; &#125; // 调用service更新商品信息，页面需要将商品信息传到此方法 itemsService.updateItems(id, itemsCustom); return "items/editItems"; &#125; jsp页面123456&lt;!-- 显示错误信息 --&gt;&lt;c:if test="$&#123;allErrors!=null &#125;"&gt; &lt;c:forEach items="$&#123;allErrors &#125;" var="error"&gt;$&#123;error.defaultMessage&#125;&lt;br /&gt; &lt;/c:forEach&gt;&lt;/c:if&gt; 分组校验在pojo中定义校验规则，而pojo是被多个 controller所共用，当不同的controller方法对同一个pojo进行校验，但是每个controller方法需要不同的校验。 解决方法：定义多个校验分组（其实是一个java接口），分组中定义有哪些规则每个controller方法使用不同的校验分组 校验分组12345public interface ValidGroup1 &#123; //接口中不需要定义任何方法，仅是对不同的校验规则进行分组 //此分组只校验商品名称长度&#125; 在校验规则中添加分组12345//校验名称在1到30字符中间 //message是提示校验出错显示的信息 //groups：此校验属于哪个分组，groups可以定义多个分组 @Size(min=1,max=30,message="&#123;items.name.length.error&#125;",groups=&#123;ValidGroup1.class&#125;) private String name; 在controller方法使用指定分组的校验123456789// value=&#123;ValidGroup1.class&#125;指定使用ValidGroup1分组的 校验@RequestMapping("/editItemsSubmit")public String editItemsSubmit( Model model, HttpServletRequest request, Integer id, @Validated(value = &#123; ValidGroup1.class &#125;) ItemsCustom itemsCustom, BindingResult bindingResult ) throws Exception &#123; 校验注解12345678910111213141516171819@Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 数据回显简单数据类型对于简单数据类型，如：Integer、String、Float等使用Model将传入的参数再放到request域实现显示。12//传入的id重新放到request域model.addAttribute("id", id); pojo类型springmvc自动将形参中的pojo重新放回request域中，request的key为pojo的类名（首字母小写）12345@RequestMapping("/editItemsSubmit")public String editItemsSubmit( Integer id, ItemsCustom itemsCustom, ) throws Exception &#123; springmvc自动将itemsCustom放回request，相当于调用下边的代码：1model.addAttribute("itemsCustom", itemsCustom); 123456789&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="name" value="$&#123;itemsCustom.name &#125;" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="price" value="$&#123;itemsCustom.price &#125;" /&gt;&lt;/td&gt;&lt;/tr&gt; 如果key不是pojo的类名，使用@ModelAttribute完成数据回显,即&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;${item.name }&quot;/&gt;时。 绑定参数 12@RequestMapping("/editItemSubmit") public String editItemSubmit(Model model,@ModelAttribute("item") ItemsCustom itemsCustom) model.addAttribute 1model.addAttribute("item", itemsCustom) 异常处理系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理. springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。 自定义异常类1234567891011121314151617181920package ccut.rj.springmvc_mybatis.exception;public class CustomException extends Exception &#123; //异常信息 public String message; public CustomException(String message)&#123; super(message); this.message = message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 全局异常处理器思路： 系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。 全局异常处理器处理思路： 解析出异常类型 如果该 异常类型是系统 自定义的异常，直接取出异常信息，在错误页面展示 如果该 异常类型不是系统 自定义的异常，构造一个自定义的异常类型（信息为“未知错误”） 实现HandlerExceptionResolver接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package ccut.rj.springmvc_mybatis.exception;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;public class CustomExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //handler就是处理器适配器要执行Handler对象（只有method） // 解析出异常类型// 如果该 异常类型是系统 自定义的异常，直接取出异常信息，在错误页面展示// String message = null;// if(ex instanceof CustomException)&#123;// message = ((CustomException)ex).getMessage();// &#125;else&#123;//// 如果该 异常类型不是系统 自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）// message="未知错误";// &#125; //上边代码变为 CustomException customException = null; if(ex instanceof CustomException)&#123; customException = (CustomException)ex; &#125;else&#123; customException = new CustomException("未知错误"); &#125; //错误信息 String message = customException.getMessage(); ModelAndView modelAndView = new ModelAndView(); //将错误信息传到页面 modelAndView.addObject("message", message); //指向错误页面 modelAndView.setViewName("error"); return modelAndView; &#125;&#125; 错误页面123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;错误提示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;message &#125;&lt;/body&gt;&lt;/html&gt; 配置springmvc123&lt;!-- 全局异常处理器 ：实现HandlerExceptionResolver接口就是全局异常处理器 --&gt;&lt;bean id="handlerExceptionResolver" class="ccut.rj.springmvc_mybatis.exception.CustomExceptionResolver" /&gt; 上传图片加入jar包 commons-io commons-fileupload springmvc中对多部件类型的解析页面form提交enctype=”multipart/form-data”的数据时，需要进行配置对multipart类型的数据进行解析。12345678&lt;!-- 文件上传 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设置上传文件的最大尺寸为5MB --&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 创建虚拟目录存储图片图形界面配置 文件配置：项目Servers-&gt; Tomcat vXXX -&gt; server.xml12&lt;Context docBase="/Users/fate7/Documents/eclipse-workspace/upload" path="/pic" reloadable="true" /&gt; ps:图片目录分级创建可以提高I/O性能，一般采用日期分级创建。 代码示例jsp12345678910&lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td&gt; &lt;c:if test="$&#123;itemsCustom.pic !=null&#125;"&gt; &lt;img src="/pic/$&#123;itemsCustom.pic&#125;" width=100 height=100/&gt; &lt;br/&gt; &lt;/c:if&gt; &lt;input type="file" name="items_pic"/&gt; &lt;/td&gt;&lt;/tr&gt; controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@RequestMapping("/editItemsSubmit")public String editItemsSubmit(Model model, HttpServletRequest request, Integer id, @Validated ItemsCustom itemsCustom, BindingResult bindingResult, MultipartFile items_pic// 接收商品图片) throws Exception &#123; // 获取校验错误信息 if (bindingResult.hasErrors()) &#123; // 输出错误信息 List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors(); for (ObjectError objectError : allErrors) &#123; // 输出错误信息 System.out.println(objectError.getDefaultMessage()); &#125; // 将错误信息传到页面 model.addAttribute("allErrors", allErrors); model.addAttribute("itemsCustom", itemsCustom); // 出错重新到商品修改页面 return "items/editItems"; &#125; // 原始名称 String originalFilename = items_pic.getOriginalFilename(); // 上传图片 if (items_pic != null &amp;&amp; originalFilename != null &amp;&amp; originalFilename.length() &gt; 0) &#123; // 存储图片的物理路径 String pic_path = "/Users/fate7/Documents/eclipse-workspace/upload/"; // 新的图片名称 String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(".")); // 新图片 File newFile = new File(pic_path + newFileName); // 将内存中的数据写入磁盘 items_pic.transferTo(newFile); // 将新图片名称写到itemsCustom中 itemsCustom.setPic(newFileName); &#125; // 调用service更新商品信息，页面需要将商品信息传到此方法 itemsService.updateItems(id, itemsCustom); return "success";&#125; json数据交互json数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。 json对比key/value 流程分析：json 客户端的请求 -&gt; 请求的是json串，需要指定contentType=application/json -&gt; @RequestBody 将json串转成java对象 -&gt; @ResponseBody 将java对象转成json串输出 -&gt; 输出json数据 流程分析：key/value 客户端的请求 -&gt; 请求的是key/value串，需要指定contentType=application/x-www-form-url -&gt; 不需要@RequestBody 将json串转成java对象 -&gt; @ResponseBody 将java对象转成json串输出 -&gt; 输出json数据 ps: 最终都输出json数据，为了前端对结果的解析 jar包springmvc中使用jackson的包进行json转换（@requestBody和@responseBody） jackson-core-asl jackson-mapper-asl ps:注意版本，spring4以后需要高版本的，比如2.8.2 json转换器 在注解适配器中加入messageConverters 12345678&lt;!--注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 采用mvc:annotation-driven/则不需要额外配置。 输入json，输出json12345678910111213//请求json，输出是jsonfunction requestJson()&#123; $.ajax(&#123; type:'post', url:'$&#123;pageContext.request.contextPath &#125;/requestJson.action', contentType:'application/json;charset=utf-8', //数据格式是json串，商品信息 data:'&#123;"name":"手机","price":999&#125;', success:function(data)&#123;//返回json结果 alert(data.name); &#125; &#125;);&#125; 123456789//请求json串(商品信息)，输出json(商品信息) //@RequestBody将请求的商品信息的json串转成itemsCustom对象 //@ResponseBody将itemsCustom转成json输出 @RequestMapping("/requestJson") public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom)&#123; //@ResponseBody将itemsCustom转成json输出 return itemsCustom; &#125; 输入key/value，输出json1234567891011121314151617//请求key/value，输出是jsonfunction responseJson()&#123; $.ajax(&#123; type:'post', url:'$&#123;pageContext.request.contextPath &#125;/responseJson.action', //请求是key/value这里不需要指定contentType，因为默认就 是key/value类型 //contentType:'application/json;charset=utf-8', //数据格式是json串，商品信息 data:'name=手机&amp;price=999', success:function(data)&#123;//返回json结果 alert(data.name); &#125; &#125;); &#125; 1234567//请求key/value，输出json@RequestMapping("/responseJson")public @ResponseBody ItemsCustom responseJson(ItemsCustom itemsCustom)&#123; //@ResponseBody将itemsCustom转成json输出 return itemsCustom;&#125; RESTful支持RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。 1、对url进行规范，写RESTful格式的url 非REST的url：http://…../queryItems.action?id=001&amp;type=T01REST的url风格：http://…./items/001 特点：url简洁，将参数通过url传到服务端2、http的方法规范不管是删除、添加、更新。。使用url是一致的，如果进行删除，需要设置http的方法为delete，同理添加。。。 后台controller方法：判断http方法，如果是delete执行删除，如果是post执行添加。 3、对http的contentType规范请求时指定contentType，要json数据，设置成json格式的type。。 RESTful示例controller123456789101112// 查询商品信息，输出json/// itemsView/&#123;id&#125;里边的&#123;id&#125;表示占位符，通过@PathVariable获取占位符中的参数，// 如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称@RequestMapping("/itemsView/&#123;id&#125;")public @ResponseBody ItemsCustom itemsView(@PathVariable("id") Integer id) throws Exception &#123; // 调用service查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(id); return itemsCustom;&#125; @RequestMapping(value=”/itemsView/{id}”)：{×××}占位符，请求的URL可以是“/viewItems/1”或“/viewItems/2”，通过在方法中使用@PathVariable获取{×××}中的×××变量。 @PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。如果RequestMapping中表示为”/itemsView/{id}”，id和形参名称一致，@PathVariable不用指定名称。 前端控制器web.xml1234567891011121314&lt;!-- springmvc前端控制器，rest配置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 静态资源解析springmvc.xml123&lt;!-- 静态资源解析 包括 ：js、css、img、.. --&gt;&lt;mvc:resources location="/js/" mapping="/js/**" /&gt;&lt;mvc:resources location="/img/" mapping="/img/**" /&gt; 拦截器定义拦截器实现HandlerInterceptor接口，实现三个方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package ccut.rj.springmvc_mybatis.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class HandlerInterceptor1 implements HandlerInterceptor &#123; //进入 Handler方法之前执行 //用于身份认证、身份授权 //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("HandlerInterceptor1...preHandle"); //return false表示拦截，不向下执行 //return true表示放行 return true; &#125; //进入Handler方法之后，返回modelAndView之前执行 //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("HandlerInterceptor1...postHandle"); &#125; //执行Handler完成执行此方法 //应用场景：统一异常处理，统一日志处理 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("HandlerInterceptor1...afterCompletion"); &#125;&#125; 配置拦截器springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该 HandlerMapping映射成功的handler最终使用该 拦截器。 不推荐使用 1234567891011&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt; &lt;property name="interceptors"&gt; &lt;list&gt; &lt;ref bean="handlerInterceptor1"/&gt; &lt;ref bean="handlerInterceptor2"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="handlerInterceptor1" class="springmvc.intercapter.HandlerInterceptor1"/&gt;&lt;bean id="handlerInterceptor2" class="springmvc.intercapter.HandlerInterceptor2"/&gt; 全局拦截器springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。 1234567891011121314&lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;!--多个拦截器,顺序执行 --&gt; &lt;mvc:interceptor&gt; &lt;!-- /**表示所有url包括子url路径 --&gt; &lt;mvc:mapping path="/**" /&gt; &lt;bean class="ccut.rj.springmvc_mybatis.interceptor.HandlerInterceptor1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt; &lt;bean class="ccut.rj.springmvc_mybatis.interceptor.HandlerInterceptor2"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 多个拦截器的执行顺序以拦截器HandlerInterceptor1，HandlerInterceptor2为例： 1，2都放行HandlerInterceptor1…preHandleHandlerInterceptor2…preHandle HandlerInterceptor2…postHandleHandlerInterceptor1…postHandle HandlerInterceptor2…afterCompletionHandlerInterceptor1…afterCompletion preHandle方法按顺序执行， postHandle和afterCompletion按拦截器配置的逆向顺序执行。 1不放行，2放行HandlerInterceptor1…preHandleHandlerInterceptor2…preHandleHandlerInterceptor1…afterCompletion 拦截器1放行，拦截器2 preHandle才会执行。 拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。 只要有一个拦截器不放行，postHandle不会执行。 1，2 都不放行HandlerInterceptor1…preHandle 拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。 拦截器1 preHandle不放行，拦截器2不执行。 拦截器应用比如：统一日志处理拦截器，需要该 拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。 比如：登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限） 登录认证拦截实现登录控制器123456789101112131415161718192021222324252627282930313233343536package ccut.rj.springmvc_mybatis.controller;import javax.servlet.http.HttpSession;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class LoginController &#123; // 登陆 @RequestMapping("/login") public String login(HttpSession session, String username, String password) throws Exception &#123; // 调用service进行用户身份验证 // ... // 在session中保存用户身份信息 session.setAttribute("username", username); // 重定向到商品列表页面 return "redirect:/items/queryItems.action"; &#125; // 退出 @RequestMapping("/logout") public String logout(HttpSession session) throws Exception &#123; // 清除session session.invalidate(); // 重定向到商品列表页面 return "redirect:/items/queryItems.action"; &#125;&#125; 登录页面12345678910111213141516&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;系统登陆&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/login.action" method="post"&gt;用户账号：&lt;input type="text" name="username" /&gt;&lt;br/&gt;用户密码 ：&lt;input type="password" name="password" /&gt;&lt;br/&gt;&lt;input type="submit" value="登陆"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登录拦截器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package ccut.rj.springmvc_mybatis.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class LoginInterceptor implements HandlerInterceptor &#123; //进入 Handler方法之前执行 //用于身份认证、身份授权 //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取请求的url String url = request.getRequestURI(); //判断url是否是公开 地址（实际使用时将公开 地址配置配置文件中） //这里公开地址是登陆提交的地址 if(url.indexOf("login.action")&gt;=0)&#123; //如果进行登陆提交，放行 return true; &#125; //判断session HttpSession session = request.getSession(); //从session中取出用户身份信息 String username = (String) session.getAttribute("username"); if(username != null)&#123; //身份存在，放行 return true; &#125; //执行这里表示用户身份需要认证，跳转登陆页面 request.getRequestDispatcher("/WEB-INF/jsp/login.jsp").forward(request, response); //return false表示拦截，不向下执行 //return true表示放行 return false; &#125; //进入Handler方法之后，返回modelAndView之前执行 //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("Login...postHandle"); &#125; //执行Handler完成执行此方法 //应用场景：统一异常处理，统一日志处理 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("Login...afterCompletion"); &#125;&#125; 拦截器配置12345&lt;!-- 登陆认证拦截器 --&gt;&lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="ccut.rj.springmvc_mybatis.interceptor.LoginInterceptor"&gt;&lt;/bean&gt;&lt;/mvc:interceptor&gt;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习SpringMVC - day2]]></title>
    <url>%2F2019%2F05%2F27%2F%E5%AD%A6%E4%B9%A0SpringMVC-day2%2F</url>
    <content type="text"><![CDATA[SpringMVC和Mybatis整合整合的架构 架构图释 整合说明 第一步：整合dao层 mybatis和spring整合，通过spring管理mapper接口。 使用mapper的扫描器自动扫描mapper接口在spring中进行注册。 第二步：整合service层 通过spring管理 service接口。 使用配置方式将service接口配置在spring配置文件中。 实现事务控制。 第三步：整合springmvc 由于springmvc是spring的模块，不需要整合。 环境说明 数据库环境： mysql8.0 Java环境：eclipse + jdk8 需要的jar包mysql-connection-javaSpringSpringMVCMybatisMyabtis和Spring的整合包dbcplog4jjstl 开始整合整合daomybatis和Spring整合 sqlMapConfig.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 全局setting配置，根据需要添加 --&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 批量扫描别名 --&gt; &lt;package name="ccut.rj.springmvc_mybatis.pojo"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置mapper 由于使用spring和mybatis的整合包进行mapper扫描，这里不需要配置了。 必须遵循：mapper.xml和mapper.java文件同名且在一个目录 --&gt;&lt;/configuration&gt; applicationContext-dao.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt; &lt;!-- 加载db.properties文件中的内容，db.properties文件中key命名要有一定的特殊规则 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置数据源 ，dbcp --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="30" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis/sqlMapConfig.xml" /&gt; &lt;/bean&gt; &lt;!-- mapper扫描器 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开 --&gt; &lt;property name="basePackage" value="ccut.rj.springmvc_mybatis.mapper"&gt;&lt;/property&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;context:annotation-config /&gt;&lt;/beans&gt; 需要配置的项 数据源 SqlSessionFactory mapper扫描器 Mapper 逆向工程生成pojo类和mapper（单表增删改查） 使用generatorSqlmapCustom 手动定义商品查询 针对综合查询mapper，一般情况会有关联查询，需自定义mapper ItemsMapperCustom.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="ccut.rj.springmvc_mybatis.mapper.ItemsMapperCustom" &gt; &lt;!-- 定义商品查询的sql片段，就是商品查询条件 --&gt; &lt;sql id="query_items_where"&gt; &lt;!-- 使用动态sql，通过if判断，满足条件进行sql拼接 --&gt; &lt;!-- 商品查询条件通过ItemsQueryVo包装对象 中itemsCustom属性传递 --&gt; &lt;if test="itemsCustom!=null"&gt; &lt;if test="itemsCustom.name!=null and itemsCustom.name!=''"&gt; items.name LIKE '%$&#123;itemsCustom.name&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; &lt;!-- 商品列表查询 --&gt; &lt;!-- parameterType传入包装对象(包装了查询条件) resultType建议使用扩展对象 --&gt; &lt;select id="findItemsList" parameterType="ccut.rj.springmvc_mybatis.pojo.ItemsQueryVo" resultType="ccut.rj.springmvc_mybatis.pojo.ItemsCustom"&gt; SELECT items.* FROM items &lt;where&gt; &lt;include refid="query_items_where"&gt;&lt;/include&gt; &lt;/where&gt; &lt;/select&gt; &lt;/mapper&gt; ItemsMapperCustom.java1234567891011package ccut.rj.springmvc_mybatis.mapper;import ccut.rj.springmvc_mybatis.pojo.ItemsCustom;import ccut.rj.springmvc_mybatis.pojo.ItemsQueryVo;import java.util.List;public interface ItemsMapperCustom &#123; //商品查询列表 public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;&#125; 定义items类的扩展类ItemsCustom1234567package ccut.rj.springmvc_mybatis.pojo;public class ItemsCustom extends Items &#123; //添加商品信息的扩展属性 &#125; 查询时使用包装类ItemsQueryVo123456789101112131415161718192021222324252627package ccut.rj.springmvc_mybatis.pojo;public class ItemsQueryVo &#123; //商品信息 private Items items; //为了系统 可扩展性，对原始生成的po进行扩展 private ItemsCustom itemsCustom; public Items getItems() &#123; return items; &#125; public void setItems(Items items) &#123; this.items = items; &#125; public ItemsCustom getItemsCustom() &#123; return itemsCustom; &#125; public void setItemsCustom(ItemsCustom itemsCustom) &#123; this.itemsCustom = itemsCustom; &#125;&#125; 整合service 定义service接口123456789101112package ccut.rj.springmvc_mybatis.service;import ccut.rj.springmvc_mybatis.pojo.ItemsQueryVo;import java.util.List;import ccut.rj.springmvc_mybatis.pojo.ItemsCustom;public interface ItemsService &#123; //商品查询列表 public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;&#125; 123456789101112131415161718192021222324252627package ccut.rj.springmvc_mybatis.service.Impl;import java.util.List;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import ccut.rj.springmvc_mybatis.mapper.ItemsMapperCustom;import ccut.rj.springmvc_mybatis.pojo.Items;import ccut.rj.springmvc_mybatis.pojo.ItemsCustom;import ccut.rj.springmvc_mybatis.pojo.ItemsQueryVo;import ccut.rj.springmvc_mybatis.service.ItemsService;public class ItemsServiceImpl implements ItemsService&#123; @Autowired private ItemsMapperCustom itemsMapperCustom; @Override public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception &#123; //通过ItemsMapperCustom查询数据库 return itemsMapperCustom.findItemsList(itemsQueryVo); &#125;&#125; applicationContext-service.xml 12345678910111213&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd "&gt; &lt;!-- 商品管理的service --&gt; &lt;bean id="itemsService" class="ccut.rj.springmvc_mybatis.service.Impl.ItemsServiceImpl" /&gt; &lt;/beans&gt; applicationContext-transaction.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.1.xsd "&gt; &lt;!-- 事务管理器 对mybatis操作数据库事务控制，spring使用jdbc的事务控制类 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 dataSource在applicationContext-dao.xml中配置了 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="save*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* ccut.rj.springmvc_mybatis.service.Impl.*.*(..))" /&gt; &lt;/aop:config&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 整合springmvc springmvc.xml 1234567891011121314151617181920212223242526272829303132&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd "&gt; &lt;!-- 可以扫描controller、service、... 这里让扫描controller，指定controller的包 --&gt; &lt;context:component-scan base-package="ccut.rj.springmvc_mybatis.controller"/&gt; &lt;!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 前端控制器 - web.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;springmvc_mybatis&lt;/display-name&gt; &lt;!-- springmvc前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 第一种：*.action，访问以.action结尾 由DispatcherServlet进行解析 第二种：/，所以访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析 使用此种方式可以实现 RESTful风格的url 第三种：/*，这样配置不对，使用这种配置，最终要转发到一个jsp页面时， 仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错。 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 编写Controller（Handler） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package ccut.rj.springmvc_mybatis.controller;import java.util.List;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import ccut.rj.springmvc_mybatis.pojo.ItemsCustom;import ccut.rj.springmvc_mybatis.service.ItemsService;//使用Controller标识 它是一个控制器@Controllerpublic class ItemsController &#123; @Autowired private ItemsService itemsService; // 商品查询列表 // @RequestMapping实现 对queryItems方法和url进行映射，一个方法对应一个url // 一般建议将url和方法写成一样 @RequestMapping("/queryItems") public ModelAndView queryItems(HttpServletRequest request) throws Exception &#123; // 调用service查找 数据库，查询商品列表，这里使用静态数据模拟 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null); // 返回ModelAndView ModelAndView modelAndView = new ModelAndView(); // 相当 于request的setAttribut，在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList", itemsList); // 指定视图 // 下边的路径，如果在视图解析器中配置jsp路径的前缀和jsp路径的后缀，修改为 // modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp"); // 上边的路径配置可以不在程序中指定jsp路径的前缀和jsp路径的后缀 modelAndView.setViewName("items/itemsList"); return modelAndView; &#125;&#125; jsp 加载Spring容器在web.xml中，添加spring容器监听器，加载spring容器。12345678&lt;!-- 加载spring容器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/spring/applicationContext-*.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 加入修改功能需求操作流程：1、进入商品查询列表页面 2、点击修改，进入商品修改页面，页面中显示了要修改的商品（从数据库查询） 要修改的商品从数据库查询，根据商品id(主键)查询商品信息 3、在商品修改页面，修改商品信息，修改后，点击提交 开发mappermapper： 根据id查询商品信息 根据id更新Items表的数据 开发service接口功能： 根据id查询商品信息 修改商品信息 123456789101112131415161718192021//根据id查询商品信息/** * * &lt;p&gt;Title: findItemsById&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param id 查询商品的id * @return * @throws Exception */public ItemsCustom findItemsById(Integer id) throws Exception;//修改商品信息/** * * &lt;p&gt;Title: updateItems&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param id 修改商品的id * @param itemsCustom 修改的商品信息 * @throws Exception */public void updateItems(Integer id,ItemsCustom itemsCustom) throws Exception; 12345678910111213141516171819202122232425262728@Autowiredprivate ItemsMapper itemsMapper;@Overridepublic ItemsCustom findItemsById(Integer id) throws Exception &#123; Items items = itemsMapper.selectByPrimaryKey(id); //中间对商品信息进行业务处理 //.... //返回ItemsCustom ItemsCustom itemsCustom = new ItemsCustom(); //将items的属性值拷贝到itemsCustom BeanUtils.copyProperties(items, itemsCustom); return itemsCustom; &#125;@Overridepublic void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception &#123; //添加业务校验，通常在service接口对关键参数进行校验 //校验 id是否为空，如果为空抛出异常 //更新商品信息使用updateByPrimaryKeyWithBLOBs根据id更新items表中所有字段，包括 大文本类型字段 //updateByPrimaryKeyWithBLOBs要求必须转入id itemsCustom.setId(id); itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);&#125; 开发controller方法： 商品信息修改页面显示 商品信息修改提交 @RequestMappingurl映射定义controller方法对应的url，进行处理器映射使用。value的值是数组，可以将多个url映射到同一个方法 1234// @RequestMapping实现 对queryItems方法和url进行映射，一个方法对应一个url// 一般建议将url和方法写成一样@RequestMapping("/queryItems")public ModelAndView queryItems(HttpServletRequest request) throws Exception &#123; 窄化请求映射在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。 访问地址为：/item/queryItems12345@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.action@RequestMapping("/items")public class ItemsController &#123; 限制http请求方法出于安全性考虑，对http的链接进行方法限制。如果限制请求为post方法，进行get请求，报错：HTTP Status 405 - Request method ‘GET’ not supported 12//限制http请求方法，可以post和get@RequestMapping(value="/editItems",method=&#123;RequestMethod.POST,RequestMethod.GET&#125;) controller方法的返回值返回ModelAndView需要方法结束时，定义ModelAndView，将model和view分别进行设置。123456789101112131415161718@RequestMapping("/editItems")// 限制http请求方法，可以post和get@RequestMapping(value="/editItems",method=&#123;RequestMethod.POST,RequestMethod.GET&#125;)public ModelAndView editItems() throws Exception &#123; // 调用service根据商品id查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(1); // 返回ModelAndView ModelAndView modelAndView = new ModelAndView(); // 将商品信息放到model modelAndView.addObject("itemsCustom", itemsCustom); // 商品修改页面 modelAndView.setViewName("items/editItems"); return modelAndView;&#125; 返回string如果controller方法返回string， 表示返回逻辑视图名。真正视图(jsp路径)=前缀+逻辑视图名+后缀 123456789101112@RequestMapping(value = "/editItems", method = &#123; RequestMethod.POST, RequestMethod.GET &#125;)public String editItems(Model model) throws Exception &#123; // 调用service根据商品id查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(1); // 通过形参中的model将model数据传到页面 // 相当于modelAndView.addObject方法 model.addAttribute("itemsCustom", itemsCustom); return "items/editItems";&#125; redirect重定向商品修改提交后，重定向到商品查询列表。redirect重定向特点：浏览器地址栏中的url会变化。修改提交的request数据无法传到重定向的地址。因为重定向后重新进行request（request无法共享） 123456@RequestMapping("/editItemsSubmit")public String editItemsSubmit(HttpServletRequest request) throws Exception &#123; // 重定向到商品查询列表 return "redirect:queryItems.action";&#125; 3、forward页面转发通过forward进行页面转发，浏览器地址栏url不变，request可以共享。12345@RequestMapping("/editItemsSubmit")public String editItemsSubmit(HttpServletRequest request) throws Exception &#123; // 页面转发 return "forward:queryItems.action";&#125; 返回void在controller方法形参上可以定义request和response，使用request或response指定响应结果：1、使用request转向页面，如下：request.getRequestDispatcher(“页面路径”).forward(request, response); 2、也可以通过response页面重定向：response.sendRedirect(“url”) 3、也可以通过response指定响应结果，例如响应json数据如下：response.setCharacterEncoding(“utf-8”);response.setContentType(“application/json;charset=utf-8”);response.getWriter().write(“json串”); 参数绑定spring参数绑定过程从客户端请求key/value数据，再经过处理器适配器调用springmvc提供参数绑定组件将key/value数据转成controller方法的形参。 springmvc中，接收页面提交的数据是通过方法形参来接收。而不是在controller类定义成员变更接收！ 参数绑定组件： 在spring的早期版本使用PropertyEditer（只能将字符串转换成java对象）后期使用converter（进行任意类型的转换）springmvc提供了很多converter（转换器）在特殊情况下需要自定义converter。对日期数据绑定需要自定义converter。 默认支持的类型直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。 HttpServletRequest通过request对象获取请求信息 HttpServletResponse通过response处理响应信息 HttpSession通过session对象得到session中存放的对象 Model/ModelMapmodel是一个接口，modelMap是一个接口实现 。作用：将model数据填充到request域。 简单类型通过@RequestParam对简单类型的参数进行绑定。如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。 如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，报下边错误：HHTP status 400 - required Integer parameter ‘id’ is not present 1234// @RequestParam里边指定request传入参数名称和形参进行绑定。 // 通过required属性指定参数是否必须要传入 // 通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。 public String editItems(Model model, @RequestParam(value = "id", required = true) Integer items_id) throws Exception &#123; pojo绑定页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo。 页面定义：12345678&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="name" value="$&#123;itemsCustom.name &#125;" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="price" value="$&#123;itemsCustom.price &#125;" /&gt;&lt;/td&gt;&lt;/tr&gt; controller的pojo形参的定义：1234public class Items &#123; private Integer id; private String name; private Float price; 自定义参数绑定实现日期类型绑定将请求日期数据串传成 日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。所以自定义参数绑定将日期串转成java.util.Date类型。需要向处理器适配器中注入自定义的参数绑定组件。 自定义日期类型绑定 1234567891011121314151617181920212223242526272829package ccut.rj.springmvc_mybatis.controller.converter;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.core.convert.converter.Converter;public class CustomDateConverter implements Converter&lt;String,Date&gt;&#123; @Override public Date convert(String source) &#123; //实现 将日期串转成日期类型(格式是yyyy-MM-dd HH:mm:ss) SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); try &#123; //转成直接返回 return simpleDateFormat.parse(source); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //如果参数绑定失败返回null return null; &#125;&#125; 配置方式 12345678910111213141516&lt;mvc:annotation-driven conversion-service="conversionService"/&gt;&lt;!-- 自定义参数绑定 --&gt;&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;!-- 转换器 --&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;!-- 日期类型转换 --&gt; &lt;bean class="ccut.rj.springmvc_mybatis.controller.converter.CustomDateConverter" /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; or 12345678910111213141516171819202122&lt;!--注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="webBindingInitializer" ref="customBinder"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 自定义webBinder --&gt; &lt;bean id="customBinder" class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer"&gt; &lt;property name="conversionService" ref="conversionService" /&gt; &lt;/bean&gt; &lt;!-- conversionService --&gt; &lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;!-- 转换器 --&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="ccut.rj.springmvc_mybatis.controller.converter.CustomDateConverter"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 问题404 HTTP Status 404 -/spring…/WEB-INF/jsp/…页面找不到，视图找不到 HTTP Status 404 -HandlerMapping根据url美誉找到Handler post乱码在web.xml添加post乱码filter 在web.xml中加入：12345678910111213&lt;!-- post乱码过虑器 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 以上可以解决post请求乱码问题。对于get请求中文参数出现乱码解决方法有两个： 修改tomcat配置文件添加编码与工程编码一致，如下1&lt;Connector URIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/&gt; 另外一种方法对参数进行重新编码：12String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;) ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Mybatis</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个SSM整合项目]]></title>
    <url>%2F2019%2F05%2F25%2F%E7%AC%AC%E4%B8%80%E4%B8%AASSM%E6%95%B4%E5%90%88%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[原文地址https://my.oschina.net/finchxu/blog/3007984 介绍环境 Mac OS 10.14.5 jdk1.8 IntelliJ idea MySQL8.0.12 mycli 1.19。0 Tomcat 9 Maven Spring 4 SpringMVC Mybatis 3.4 目录结构展示 新建项目 创建如图的maven的webapp项目 groupid和artifactid GroupID 是项目组织唯一的标识符，实际对应JAVA的包的结构，是main目录里java的目录结构。 ArtifactID是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。 项目详情创建数据库CREATE DATABASE books; use books; CREATE TABLE `bookadmin` ( `bid` int(11) NOT NULL AUTO_INCREMENT, `bn` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `author` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `press` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, PRIMARY KEY (`bid`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 14 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; 配置pom.xml完成jar包的导入和Maven项目管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ccut.rj.czq&lt;/groupId&gt; &lt;artifactId&gt;demo-ssm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;demo-ssm Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring.version&gt;4.3.19.RELEASE&lt;/spring.version&gt; &lt;validator.version&gt;5.2.4.Final&lt;/validator.version&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt; &lt;commons-io.version&gt;2.4&lt;/commons-io.version&gt; &lt;commons-codec.version&gt;1.9&lt;/commons-codec.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;commons-beanutils.version&gt;1.9.1&lt;/commons-beanutils.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- WEB begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;!-- WEB end --&gt; &lt;!-- SPRING begin --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.esotericsoftware.reflectasm&lt;/groupId&gt; &lt;artifactId&gt;reflectasm&lt;/artifactId&gt; &lt;version&gt;1.09&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring orm --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- bean validate --&gt; &lt;!-- SPRING end --&gt; &lt;!-- AOP begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- AOP end --&gt; &lt;!-- TEST begin --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- TEST end --&gt; &lt;!-- LOGGING begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- common-logging 实际调用slf4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java.util.logging 实际调用slf4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- LOGGING end --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-codec.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-beanutils.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;demo-ssm&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;6&lt;/source&gt; &lt;target&gt;6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; properties 定义Maven的属性 dependencies 所需jar包的导入 resources 在maven打包war时扫描这些xml文件 Spring配置文件 applicationContext-dao.xml 用的dbcp连接池。 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties"/&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;!-- 连接池的最大数据库连接数 --&gt; &lt;property name="maxActive" value="$&#123;jdbc.maxActive&#125;"/&gt; &lt;!-- 最大空闲数 --&gt; &lt;property name="maxIdle" value="$&#123;jdbc.maxIdle&#125;"/&gt; &lt;/bean&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 加载mybatis核心配置文件 --&gt; &lt;property name="configLocation" value="classpath:sqlMapConfig.xml"/&gt; &lt;!-- 别名包扫描 --&gt; &lt;property name="typeAliasesPackage" value="ccut.book.pojo"/&gt; &lt;/bean&gt; &lt;!-- 动态代理，第二种方式：包扫描（推荐）： --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- basePackage多个包用","分隔 --&gt; &lt;property name="basePackage" value="ccut.book.mapper"/&gt; &lt;/bean&gt;&lt;/beans&gt; 导入jdbc.properties; 设置数据库连接池（dbcp）; 创建sqlSessionFactory，加载sqlMapConfig.xml; 扫描mapper（包扫描） applicationContext-service.xml1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- @Service包扫描器 --&gt; &lt;context:component-scan base-package="ccut.book.service"/&gt;&lt;/beans&gt; 扫描Serviceceng applicationContext-trans.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="insert*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="query*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--&amp;lt;!&amp;ndash; 切面 &amp;ndash;&amp;gt;--&gt; &lt;!--&lt;aop:config&gt;--&gt; &lt;!--&lt;aop:advisor advice-ref="txAdvice"--&gt; &lt;!--pointcut="execution(* ccut.book.service.*.*(..))" /&gt;--&gt; &lt;!--&lt;/aop:config&gt;--&gt;&lt;/beans&gt; 配置事务管理器 设置通知 设置aop 数据库配置 jdbc.properties123456jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/books?useSSL=false&amp;serverTimezone=UTCjdbc.username=rootjdbc.password=passwordjdbc.maxActive=10jdbc.maxIdle=5 ps: mysql8这个坑货在配置文件里不能有“;” SpringMVC配置 spring-mvc.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置@controller扫描包 --&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package="ccut.book.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!-- 配置注解驱动，相当于同时使用最新处理器映射跟处理器适配器,对json数据响应提供支持 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; 扫描controller层 配置注解驱动 配置视图解析器 配置Mybatis sqlMapConfig.xml1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;/configuration&gt; web加载 web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置spring --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 使用监听器加载Spring配置文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 解决post乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 设置编码参是UTF8 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;!--这里写的是/而不是/*，因为用了后者就把jsp也当静态文件了--&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置spring 使用监听器加载Spring配置文件 解决post乱码问题 前端控制器(DispatcherServlet) pojo12345678910111213141516171819202122232425262728293031323334353637383940package ccut.book.pojo;public class Bookadmin &#123; Integer bid; String bn; String author; String press; public Integer getBid() &#123; return bid; &#125; public void setBid(Integer bid) &#123; this.bid = bid; &#125; public String getBn() &#123; return bn; &#125; public void setBn(String bn) &#123; this.bn = bn; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public String getPress() &#123; return press; &#125; public void setPress(String press) &#123; this.press = press; &#125;&#125; mapper BooksMapper.java 12345678910111213141516171819package ccut.book.mapper;import ccut.book.pojo.Bookadmin;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface BooksMapper &#123; List&lt;Bookadmin&gt; list(); public int insert(Bookadmin record); public int update(Bookadmin b); public int delete(Bookadmin bid); public Bookadmin getBookByBid(Integer bid);&#125; BooksMapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="ccut.book.mapper.BooksMapper"&gt; &lt;sql id="BASE_TABLE"&gt;bookadmin&lt;/sql&gt; &lt;select id="list" resultType="Bookadmin"&gt; select * from bookadmin &lt;/select&gt; &lt;insert id="insert" parameterType="Bookadmin"&gt; INSERT INTO &lt;include refid="BASE_TABLE"/&gt; &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; bn,author, &lt;if test="press != null"&gt; press, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="VALUES(" suffix=")" suffixOverrides=","&gt; #&#123;bn,jdbcType=VARCHAR&#125;,#&#123;author,jdbcType=VARCHAR&#125;, &lt;if test="press != null"&gt; #&#123;press,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="update" parameterType="Bookadmin"&gt; update &lt;include refid="BASE_TABLE"/&gt; set bn = #&#123;bn&#125;,author = #&#123;author&#125;,press = #&#123;press&#125; where bid = #&#123;bid&#125; &lt;/update&gt; &lt;delete id="delete" parameterType="Bookadmin"&gt; delete from &lt;include refid="BASE_TABLE"/&gt; where bid = #&#123;bid&#125; &lt;/delete&gt; &lt;select id="getBookByBid" resultType="Bookadmin"&gt; select bid,bn,author,press from bookadmin where bid = #&#123;bid&#125; &lt;/select&gt; &lt;!--resultType="Bookadmin"--&gt;&lt;/mapper&gt; service BooksService.java 12345678910111213141516171819package ccut.book.service;import ccut.book.pojo.Bookadmin;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic interface BooksService &#123; List&lt;Bookadmin&gt; list(); int insertBook(Bookadmin bookadmin); int update(Bookadmin b); int deleteBookByBid(Bookadmin bid); Bookadmin getBookByBid(int bid);&#125; BooksServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package ccut.book.service;import ccut.book.mapper.BooksMapper;import ccut.book.pojo.Bookadmin;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class BooksServiceImpl implements BooksService &#123; @Autowired private BooksMapper booksMapper; //列出数据 @Override public List&lt;Bookadmin&gt; list()&#123; List&lt;Bookadmin&gt; list = this.booksMapper.list(); return list; &#125; //插入数据 @Override public int insertBook(Bookadmin bookadmin) &#123; return booksMapper.insert(bookadmin); &#125; //更新数据 @Override public int update(Bookadmin b)&#123; return booksMapper.update(b); &#125; //删除数据 @Override public int deleteBookByBid(Bookadmin bid)&#123; return booksMapper.delete(bid); &#125; @Override public Bookadmin getBookByBid(int bid)&#123; return booksMapper.getBookByBid(bid); &#125;&#125; controller BooksController.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package ccut.book.controller;import ccut.book.pojo.Bookadmin;import ccut.book.service.BooksService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.servlet.ModelAndView;import java.util.List;@Controller@RequestMapping("/a")public class BooksController &#123; @Autowired BooksService booksService; //列出数据表格 // 设置listBooks页面(list第一种写法) @RequestMapping("/listBooks") public ModelAndView listBooks()&#123; ModelAndView mav = new ModelAndView(); List&lt;Bookadmin&gt; bb = booksService.list(); mav.addObject("bb",bb); mav.setViewName("listBooks"); return mav; &#125;// list的第二种写法// @RequestMapping("/listBooks")// public String listBooks(Model model)&#123;// List&lt;Bookadmin&gt; bb = booksService.list();// model.addAttribute("bb",bb);// return "listBooks";// &#125; // 添加数据（两部分） // 第一步：跳转到这里并添加图书信息，点击添加按钮就执行下边第二段代码 @RequestMapping("/addBooks0") public String addBooks0()&#123; return "savePage"; &#125; // 第二步：把下边的页面数据返回给后端，再跳转到listBooks页面 @RequestMapping(value = "/addBooks",method = RequestMethod.POST) public String addBooks(Bookadmin bookadmin)&#123; booksService.insertBook(bookadmin); return "redirect:listBooks"; &#125; // 修改数据（两部分） // 第一步：更新图书，先通过bid找到图书，并列在/updatepage/&#123;bid&#125;页面上， @RequestMapping("/updatepage/&#123;bid&#125;") public String updatepage(@PathVariable("bid") int bid,Model model)&#123; //int bid1 = Integer.parseInt(bid); model.addAttribute("bookadmin",booksService.getBookByBid(bid)); return "updatePage"; &#125; // 第二步：然后修改即可，在这里点更新提交数据给后端 @RequestMapping(value = "/update",method = RequestMethod.POST) public String update(Bookadmin b)&#123; booksService.update(b); return "redirect:listBooks"; &#125; // 删除图书数据 @RequestMapping("/deleteBooksByBid") public String deleteBooksByBid(Bookadmin bid)&#123; booksService.deleteBookByBid(bid); return "redirect:listBooks"; &#125;&#125; JSP文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141//listBooks.jsp&lt;%-- Created by IntelliJ IDEA. User: fate7 Date: 2019/5/17 Time: 11:15 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;listBooks&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;table align=&quot;center&quot; bgcolor=&quot;aqua&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt; &lt;tr&gt; &lt;th width=&quot;140&quot;&gt;图书BID&lt;/th&gt; &lt;th width=&quot;140&quot;&gt;书名&lt;/th&gt; &lt;th width=&quot;140&quot;&gt;作者&lt;/th&gt; &lt;th width=&quot;140&quot;&gt;出版社&lt;/th&gt; &lt;th width=&quot;140&quot;&gt;修改&lt;/th&gt; &lt;th width=&quot;140&quot;&gt;删除&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;bb&#125;&quot; var=&quot;b&quot;&gt; &lt;%--varStatus=&quot;ct&quot;--%&gt; &lt;tr&gt; &lt;td&gt;$&#123;b.bid&#125;&lt;/td&gt; &lt;td&gt;$&#123;b.bn&#125;&lt;/td&gt; &lt;td&gt;$&#123;b.author&#125;&lt;/td&gt; &lt;td&gt;$&#123;b.press&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/a/updatepage/$&#123;b.bid&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/a/deleteBooksByBid?bid=$&#123;b.bid&#125;&quot; onclick=&apos;return confirm(&quot;确认要删除吗?&quot;)&apos;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;%--&lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/a/addBooks0&quot;&gt;添加图书(跳转页面)&lt;/a&gt;&lt;/td&gt;--%&gt; &lt;/table&gt;&lt;/form&gt;&lt;form id=&quot;saveForm&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/a/addBooks&quot; method=&quot;post&quot;&gt; &lt;table align=&quot;center&quot; bgcolor=&quot;aqua&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt; &lt;tr&gt; &lt;th width=&quot;140&quot;&gt;书名&lt;/th&gt; &lt;th width=&quot;140&quot;&gt;作者&lt;/th&gt; &lt;th width=&quot;140&quot;&gt;出版社&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;140&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;$&#123;bookadmin.bn&#125;&quot; name=&quot;bn&quot;/&gt;&lt;/td&gt; &lt;td width=&quot;140&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;$&#123;bookadmin.author&#125;&quot; name=&quot;author&quot;/&gt;&lt;/td&gt; &lt;td width=&quot;140&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;$&#123;bookadmin.press&#125;&quot; name=&quot;press&quot;/&gt;&lt;/td&gt; &lt;td width=&quot;140&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;添加&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;//savePage.jsp&lt;%-- Created by IntelliJ IDEA. User: fate7 Date: 2019/5/17 Time: 11:16 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;添加图书&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt;&lt;form id=&quot;saveForm&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/a/addBooks&quot; method=&quot;post&quot;&gt; &lt;table align=&quot;center&quot; bgcolor=&quot;aqua&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;书名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;$&#123;bookadmin.bn&#125;&quot; name=&quot;bn&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;作者：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;$&#123;bookadmin.author&#125;&quot; name=&quot;author&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出版社：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;$&#123;bookadmin.press&#125;&quot; name=&quot;press&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;input type=&quot;submit&quot; value=&quot;添加&quot;/&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;//updatePage.jsp&lt;%-- Created by IntelliJ IDEA. User: fate7 Date: 2019/5/17 Time: 11:16 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;更新&amp;修改 图书信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;编辑图书信息！&lt;/h2&gt;&lt;form id=&quot;updateForm&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/a/update&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; value=&quot;$&#123;bookadmin.bid&#125;&quot; name=&quot;bid&quot;/&gt; &lt;table align=&quot;center&quot; bgcolor=&quot;aqua&quot; border=&quot;1&quot; cellpadding=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;书名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;$&#123;bookadmin.bn&#125;&quot; name=&quot;bn&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;作者：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;$&#123;bookadmin.author&#125;&quot; name=&quot;author&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出版社：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;$&#123;bookadmin.press&#125;&quot; name=&quot;press&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;input type=&quot;submit&quot; value=&quot;更新&quot;/&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 启动项目 配置Tomcat server 配置Tomcat Deploymentps: 这里的第5步，/SSM为启动的根路径 以Debug方式启动tomcat 访问页面访问http://localhost:8080/SSM/a/listBooks]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Mybatis</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>框架整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习SpringMVC - day1]]></title>
    <url>%2F2019%2F05%2F19%2F%E5%AD%A6%E4%B9%A0SpringMVC-day1%2F</url>
    <content type="text"><![CDATA[SpringMVC介绍属于表现层的框架，是Spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。springmvc是一个基于mvc的web框架。 框架结构 架构流程 1、用户发送请求至前端控制器DispatcherServlet 2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器(Controller) 5、执行处理器(Controller，也叫后端控制器)。 6、Controller执行完成返回ModelAndView 7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet 8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器 9、ViewReslover解析后返回具体View 10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。 11、 DispatcherServlet响应用户 组件说明DispatcherServlet 前端控制器用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping 处理器映射器HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 Handler 处理器Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 HandlerAdapter 处理器适配器通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 ViewResolver 视图解析器View Resolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 View 视图springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 说明： 在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。需要用户开发的组件有handler、view 入门程序创建Web项目导入jar包 commens-logging jstl - ViewResolver会用到 spring beans spring core spring context spring expression spring web spring webmvc 配置前端控制器 WEB-INF\web.xml 12345678910111213141516171819&lt;!-- springmvc前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 第一种：*.action，访问以.action结尾 由DispatcherServlet进行解析 第二种：/，所以访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析 使用此种方式可以实现 RESTful风格的url 第三种：/*，这样配置不对，使用这种配置，最终要转发到一个jsp页面时， 仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错。 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; load-on-startup：表示servlet随服务启动； url-pattern：*.action的请交给DispatcherServlet处理。 contextConfigLocation：指定springmvc配置的加载位置，如果不指定则默认加载WEB-INF/[DispatcherServlet 的Servlet 名字]-servlet.xml。 Servlet拦截方式 拦截固定后缀的url，比如设置为 .do、.action， 例如：/user/add.action此方法最简单，不会导致静态资源（jpg,js,css）被拦截。 拦截所有，设置为/，例如：/user/add /user/add.action此方法可以实现REST风格的url，很多互联网类型的应用使用这种方式。但是此方法会导致静态文件（jpg,js,css）被拦截后不能正常显示。需要特殊处理。 拦截所有，设置为/*，此设置方法错误，因为请求到Action，当action转到jsp时再次被拦截，提示不能根据jsp路径mapping成功。 springmvc配置在完成前端控制器时完成1234&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;&lt;/init-param&gt; 配置处理器适配器classpath:springmvc.xml123&lt;!-- 处理器适配器 所有处理器适配器都实现 HandlerAdapter接口 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" /&gt; SimpleControllerHandlerAdapter：即简单控制器处理适配器，所有实现了org.springframework.web.servlet.mvc.Controller 接口的Bean作为Springmvc的后端控制器。 处理器的开发123456789101112131415161718192021public class ItemList1 implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //商品列表 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); //创建modelAndView准备填充数据、设置视图 ModelAndView modelAndView = new ModelAndView(); //填充数据 modelAndView.addObject("itemsList", itemsList); //视图 modelAndView.setViewName("order/itemsList"); return modelAndView; &#125; &#125; org.springframework.web.servlet.mvc.Controller：处理器必须实现Controller 接口。ModelAndView：包含了模型数据及逻辑视图名 配置映射处理器123&lt;!-- 处理器映射器 将bean的name作为url进行查找 ，需要在配置Handler时指定beanname（就是url） 所有的映射器都实现HandlerMapping接口。 --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; BeanNameUrlHandlerMapping：表示将定义的Bean名字作为请求的url，需要将编写的controller在spring容器中进行配置，且指定bean的name为请求的url，且必须以.action结尾。 处理器的配置123&lt;!-- 配置Handler --&gt; &lt;bean id="itemsController1" name="/queryItems.action" class="ccut.rj.springmvc.controller.ItemsController1" /&gt; 配置视图解析器12345678&lt;!-- 视图解析器 解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; InternalResourceViewResolver：支持JSP视图解析viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包；prefix 和suffix：查找视图页面的前缀和后缀，最终视图的址为：前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp” 视图开发见详细代码 部署在tomcat测试http://localhost:8080/springmvc/queryItems.action 可能出现的错误404 后边没有地址：处理器映射器根据url找不到Handler，报下边的错误。说明url错误。有地址：处理器映射器根据url找到了Handler，转发的jsp页面找到，报下边的错误，说明jsp页面地址错误了。 前端控制器DispathcerServlet作为springmvc的中央调度器存在，DispatcherServlet创建时会默认从DispatcherServlet.properties文件加载springmvc所用的各各组件，如果在springmvc.xml中配置了组件则以springmvc.xml中配置的为准，DispatcherServlet的存在降低了springmvc各各组件之间的耦合度。 非注解的处理器映射器和适配器处理器映射器 org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping 1&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; org.springframework.web.servlet.handler.SimpleUrlHandlerMapping 12345678&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/queryItems1.action"&gt;itemsController1&lt;/prop&gt; &lt;prop key="/queryItems2.action"&gt;itemsController1&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; ps:多个映射器可以并存，前端控制器判断url能让哪些映射器映射，就让正确的映射器处理. 处理器适配器 org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter 要求编写的Handler实现 Controller接口。 1&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" /&gt; org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter 要求编写的Handler实现 HttpRequestHandler接口。 1&lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter" /&gt; 12345//使用此方法可以通过修改response，设置响应的数据格式，比如响应json数据response.setCharacterEncoding("utf-8");response.setContentType("application/json;charset=utf-8");response.getWriter().write("json串"); 注解的处理器映射器和适配器处理器映射器 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。 1&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt; 注解描述：@RequestMapping：定义请求url到处理器功能方法的映射 处理器适配器 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter 注解式处理器适配器，对标记@ResquestMapping的方法进行适配。 从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。 1&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt; mvc:annotation-driven使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置.mvc:annotation-driven默认加载很多的参数绑定方法，比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven1&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 注解开发实例配置映射器和适配器1&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; Handler123456789101112131415161718192021import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;//使用Controller标识 它是一个控制器@Controllerpublic class ItemsController3 &#123; //商品查询列表 //@RequestMapping实现 对queryItems方法和url进行映射，一个方法对应一个url //一般建议将url和方法写成一样 @RequestMapping("/queryItems") public ModelAndView queryItems()throws Exception&#123; ModelAndView modelAndView = new ModelAndView(); return modelAndView; &#125;&#125; spring加载Handler 单个加载 1&lt;bean id="" class=""/&gt; 组建扫描 1&lt;context:component-scan base-package=""&gt;&lt;/context:component-scan&gt; 部署调试http://localhost:8080/springmvc/queryItems4.action 详细代码web.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;springmvc&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd "&gt; &lt;!-- 配置Handler --&gt; &lt;bean id="itemsController1" name="/queryItems.action" class="ccut.rj.springmvc.controller.ItemsController1" /&gt; &lt;!-- 配置另外一个Handler --&gt; &lt;bean id="itemsController2" class="ccut.rj.springmvc.controller.ItemsController2" /&gt; &lt;!-- 对于注解的Handler可以单个配置 实际开发中建议使用组件扫描 --&gt; &lt;!-- &lt;bean class="ccut.rj.springmvc.controller.ItemsController3" /&gt; --&gt; &lt;!-- 可以扫描controller、service、... 这里让扫描controller，指定controller的包 --&gt; &lt;context:component-scan base-package="ccut.rj.springmvc.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 处理器映射器 将bean的name作为url进行查找 ，需要在配置Handler时指定beanname（就是url） 所有的映射器都实现 HandlerMapping接口。 --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; &lt;!--简单url映射 --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;!-- 对itemsController1进行url映射，url是/queryItems1.action --&gt; &lt;prop key="/queryItems1.action"&gt;itemsController1&lt;/prop&gt; &lt;prop key="/queryItems2.action"&gt;itemsController1&lt;/prop&gt; &lt;prop key="/queryItems3.action"&gt;itemsController2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--注解映射器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping" /&gt; &lt;!--注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter" /&gt; &lt;!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt; &lt;!-- &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; --&gt; &lt;!-- 处理器适配器 所有处理器适配器都实现 HandlerAdapter接口 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" /&gt; &lt;!-- 另一个非注解的适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter" /&gt; &lt;!-- 视图解析器 解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/beans&gt; ItemController1.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package ccut.rj.springmvc.controller;import java.util.ArrayList;import java.util.List;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import ccut.rj.springmvc.pojo.Items;public class ItemsController1 implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //调用service查找 数据库，查询商品列表，这里使用静态数据模拟 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName("联想笔记本1"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当 于request的setAttribut，在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList", itemsList); //指定视图 modelAndView.setViewName("items/itemsList");// /WEB-INF/jsp/items/itemsList.jsp return modelAndView; &#125;&#125; ItemController2.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package ccut.rj.springmvc.controller;import java.io.IOException;import java.util.ArrayList;import java.util.List;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.HttpRequestHandler;import ccut.rj.springmvc.pojo.Items;public class ItemsController2 implements HttpRequestHandler &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //调用service查找 数据库，查询商品列表，这里使用静态数据模拟 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); //设置模型数据 request.setAttribute("itemsList", itemsList); //设置转发的视图 request.getRequestDispatcher("/WEB-INF/jsp/items/itemsList.jsp").forward(request, response); //使用此方法可以通过修改response，设置响应的数据格式，比如响应json数据/* response.setCharacterEncoding("utf-8"); response.setContentType("application/json;charset=utf-8"); response.getWriter().write("json串");*/ &#125;&#125; ItemController3.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package ccut.rj.springmvc.controller;import java.util.ArrayList;import java.util.List;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import ccut.rj.springmvc.pojo.Items;//使用Controller标识 它是一个控制器@Controllerpublic class ItemsController3 &#123; //商品查询列表 //@RequestMapping实现 对queryItems方法和url进行映射，一个方法对应一个url //一般建议将url和方法写成一样 @RequestMapping("/queryItems4") public ModelAndView queryItems()throws Exception&#123; //调用service查找 数据库，查询商品列表，这里使用静态数据模拟 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当 于request的setAttribut，在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList", itemsList); //指定视图 //下边的路径，如果在视图解析器中配置jsp路径的前缀和jsp路径的后缀，修改为 //modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp"); //上边的路径配置可以不在程序中指定jsp路径的前缀和jsp路径的后缀 modelAndView.setViewName("items/itemsList"); return modelAndView; &#125; //定义其它的方法 //商品添加 //商品修改 &#125; itemlist.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%\&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%\&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%\&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/item/queryItem.action" method="post"&gt; 查询条件： &lt;table width="100%" border=1&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="submit" value="查询" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 商品列表： &lt;table width="100%" border=1&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;生产日期&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;itemsList &#125;" var="item"&gt; &lt;tr&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/item/editItem.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; items.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package ccut.rj.springmvc.pojo;import java.util.Date;public class Items &#123; private Integer id; private String name; private Float price; private String pic; private Date createtime; private String detail; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name == null ? null : name.trim(); &#125; public Float getPrice() &#123; return price; &#125; public void setPrice(Float price) &#123; this.price = price; &#125; public String getPic() &#123; return pic; &#125; public void setPic(String pic) &#123; this.pic = pic == null ? null : pic.trim(); &#125; public Date getCreatetime() &#123; return createtime; &#125; public void setCreatetime(Date createtime) &#123; this.createtime = createtime; &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail == null ? null : detail.trim(); &#125;&#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis - 逆向工程]]></title>
    <url>%2F2019%2F05%2F19%2FMybatis-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[项目准备 下载逆向工程的项目https://github.com/mybatis/generator 下载插件MybatisGenerator 导入项目 复制到工作空间的目录下 导入EclipseImportExisting Projects into Workspace选择逆向项目 修改配置文件 generatorConfig.xml 需要修改的部分 修改生成的数据库表 pojo文件的包路径 mapper文件的包路径 配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot; connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot; userId=&quot;yycg&quot; password=&quot;yycg&quot;&gt; &lt;/jdbcConnection&gt; --&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;cn.itcast.ssm.po&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;cn.itcast.ssm.mapper&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;cn.itcast.ssm.mapper&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;order&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; ps: 包路径中win为.\src，mac为./src 生成逆向工程代码找到java文件，执行工程main主函数 逆向工程生成的代码只能做单表查询 不能在生成的代码上进行扩展，因为如果数据库变更，需要重新使用逆向工程生成代码，原来编写的代码就被覆盖了。 一张表会生成4个文件 以表User为例：src/…pojo/User.javasrc/…pojo/UserExample.javasrc/…mapper/UserMapper.javasrc/…mapper/UserMapper.xml 测试方法UserMapper接口中的方法说明方法 |功能说明—–|——–int countByExample(UserExample example) | 按条件计数int deleteByPrimaryKey(Integer id) | 按主键删除int deleteByExample(UserExample example) | 按条件查询String/Integer insert(User record) | 插入数据（返回值为ID）User selectByPrimaryKey(Integer id) | 按主键查询ListselectByExample(UserExample example) | 按条件查询ListselectByExampleWithBLOGs(UserExample example)| 按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。int updateByPrimaryKey(User record) | 按主键更新int updateByPrimaryKeySelective(User record) | 按主键更新值不为null的字段int updateByExample(User record, UserExample example) | 按条件更新int updateByExampleSelective(User record, UserExample example) | 按条件更新值不为null的字段 在Idea中使用Maven来完成逆向在pom.xml的plugin中添加 &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Spring-整合Junit]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%AD%A6%E4%B9%A0Spring-%E6%95%B4%E5%90%88Junit%2F</url>
    <content type="text"><![CDATA[导入jar包 Spring核心包 + 日志 Spring core Spring beans Spring context Spring expression comments-logging 测试 Spring test 整合过程 让Junit通知spring加载配置文件 让spring容器自动进行注入 修改测试类1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)public class TestApp &#123; @Autowired //与junit整合，不需要在spring xml配置扫描 private AccountService accountService; @Test public void demo01()&#123; applicationContext.getBean(&quot;accountService&quot;); accountService.transfer(&quot;jack&quot;, &quot;rose&quot;, 1000); &#125;&#125;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Spring-day3]]></title>
    <url>%2F2019%2F05%2F15%2F%E5%AD%A6%E4%B9%A0Spring-day3%2F</url>
    <content type="text"><![CDATA[事务管理事务介绍特性： ACID 原子性：整体 一致性：完成 隔离性：并发 持久性：结果 隔离问题脏读： 一个事务读到另一个事务没有提交的数据 不可重复读： 一个事务读到另一个事务已提交的数据(update) 虚读(幻读)： 一个事务读到另一个事务已提交的数据(insert) 隔离级别read uncommitted: 读未提交。存在3个问题read committed：读已提交。解决脏读，存在2个问题repeatable read：可重复读。解决：脏读、不可重复读，存在1个问题。serializable：串行化。都解决，单事务。 mysql 事务操作–简单ABCD 一个事务 Connection conn = null; try{ //1 获得连接 conn = ...; //2 开启事务 conn.setAutoCommit(false); A B C D //3 提交事务 conn.commit(); } catche(){ //4 回滚事务 conn.rollback(); } mysql 事务操作–Savepoint需求：AB（必须），CD（可选） Connection conn = null; Savepoint savepoint = null; //保存点，记录操作的当前位置，之后可以回滚到指定的位置。（可以回滚一部分） try{ //1 获得连接 conn = ...; //2 开启事务 conn.setAutoCommit(false); A B savepoint = conn.setSavepoint(); C D //3 提交事务 conn.commit(); } catche(){ if(savepoint != null){ //CD异常 // 回滚到CD之前 conn.rollback(savepoint); // 提交AB conn.commit(); } else{ //AB异常 // 回滚AB conn.rollback(); } } 事务管理介绍jar包 spring-tx 顶级接口 PlatformTransactionManager 平台事务管理器，spring要管理事务，必须使用事务管理器 进行事务配置时，必须配置事务管理器。 TransactionDefinition：事务详情（事务定义、事务属性），spring用于确定事务具体详情， 例如：隔离级别、是否只读、超时时间等 进行事务配置时，必须配置详情。spring将配置项封装到该对象实例。 TransactionStatus：事务状态，spring用于记录当前事务运行状态。例如：是否有保存点，事务是否完成。 spring底层根据状态进行相应操作。 PlatformTransactionManager 事务管理器 jar包spring-jdbc spring-tx 常见的事务管理器 DataSourceTransactionManager ，jdbc开发时事务管理器，采用JdbcTemplate HibernateTransactionManager，hibernate开发时事务管理器，整合hibernate api详解TransactionStatus getTransaction(TransactionDefinition definition) ，事务管理器 通过“事务详情”，获得“事务状态”，从而管理事务。void commit(TransactionStatus status) 根据状态提交void rollback(TransactionStatus status) 根据状态回滚 TransactionStatusisNewTransaction():boolean 是否是新的事务 hasSavepoint():boolean 是否有保存点 setRollbackOnly():void 设置回滚 isRollbackOnly():boolean 是否回滚 flush():void 刷新 isCompleteed(): boolean 是否完成 TransactionDefinition 传播行为：在两个业务之间如何共享事务。 PROPAGATION_REQUIRED , required , 必须 【默认值】 支持当前事务，A如果有事务，B将使用该事务。 如果A没有事务，B将创建一个新的事务。PROPAGATION_SUPPORTS ，supports ，支持 支持当前事务，A如果有事务，B将使用该事务。 如果A没有事务，B将以非事务执行。PROPAGATION_MANDATORY，mandatory ，强制 支持当前事务，A如果有事务，B将使用该事务。 如果A没有事务，B将抛异常。PROPAGATION_REQUIRES_NEW ， requires_new ，必须新的 如果A有事务，将A的事务挂起，B创建一个新的事务 如果A没有事务，B创建一个新的事务PROPAGATION_NOT_SUPPORTED ，not_supported ,不支持 如果A有事务，将A的事务挂起，B将以非事务执行 如果A没有事务，B将以非事务执行PROPAGATION_NEVER ，never，从不 如果A有事务，B将抛异常 如果A没有事务，B将以非事务执行PROPAGATION_NESTED ，nested ，嵌套 A和B底层采用保存点机制，形成嵌套事务。 重点：PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED 案例：转账搭建基本环境 创建实验用的表 account create database spring_day03; use spring_day03; create table account( id int primary key auto_increment, username varchar(50), money int ); insert into account(username,money) values(&apos;jack&apos;,&apos;10000&apos;); insert into account(username,money) values(&apos;rose&apos;,&apos;10000&apos;); 导入jar包2.1 Spring核心包 + 日志 Spring core Spring beans Spring context Spring expression comments-logging 2.2 aop：aop联盟， aop， aspectj规范， aspect aopalliance Spring aop aspectj.weaver Spring aspect 2.3 数据库：jdbc， tx Spring jdbc Spring tx 2.4 驱动 mysql-connector-java 2.5 连接池c3p0 com.mchange.v2.c3p0 dao层 12345678910111213package com.rj.spring.Transaction.Dao;import org.springframework.jdbc.core.support.JdbcDaoSupport;public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; public void in(String inner, int money) &#123; this.getJdbcTemplate().update("update account set money = money + ? where username = ?", money, inner); &#125; public void out(String outer, int money) &#123; this.getJdbcTemplate().update("update account set money = money - ? where username = ?", money, outer); &#125;&#125; service层 1234567891011121314151617181920package com.rj.spring.Transaction.Service.impl;import com.rj.spring.Transaction.Dao.AccountDao;import com.rj.spring.Transaction.Service.accountService;public class accountServiceImpl implements accountService &#123; private AccountDao accoutDao; public void setAccoutDao(AccountDao accoutDao) &#123; this.accoutDao = accoutDao; &#125; public void transfer(String outer, String inner, int money) &#123; accoutDao.out(outer, money); //意外状况 //int i = 1/0; accoutDao.in(inner, money); &#125;&#125; spring配置文件 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring_day03?useSSL=false&amp;amp;serverTimezone=UTC"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="******"/&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.rj.spring.Transaction.Dao.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;bean id="accountServiceId" class="com.rj.spring.Transaction.Service.impl.accountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 123456789101112131415161718package com.rj.spring.Transaction.Test;import com.rj.spring.Transaction.Service.accountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestApp &#123; @Test public void demo01()&#123; String xmlPath = "applicationContext.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); accountService accountService = (accountService) applicationContext.getBean("accountServiceId"); accountService.transfer("jack", "rose", 1000); &#125;&#125; 手动管理事务 spring底层使用 TransactionTemplate 事务模板进行操作。 操作1.service 需要获得 TransactionTemplate2.spring 配置模板，并注入给service3.模板需要注入事务管理器4.配置事务管理器：DataSourceTransactionManager ，需要注入DataSource 修改service 1234567891011121314151617181920212223242526272829303132333435package com.rj.spring.Transaction.Service.impl;import com.rj.spring.Transaction.Dao.AccountDao;import com.rj.spring.Transaction.Service.accountService;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.TransactionCallbackWithoutResult;import org.springframework.transaction.support.TransactionTemplate;public class accountServiceImpl implements accountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; //需要spring注入模板 private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123; this.transactionTemplate = transactionTemplate; &#125; public void transfer(final String outer, final String inner, final int money) &#123; transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult(TransactionStatus arg0) &#123; accountDao.out(outer, money); //断电 //int i = 1/0; accountDao.in(inner, money); &#125; &#125;); &#125;&#125; 修改配置文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 创建数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring_day03?useSSL=false&amp;amp;serverTimezone=UTC"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="as980702"/&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.rj.spring.Transaction.Dao.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;bean id="accountServiceId" class="com.rj.spring.Transaction.Service.impl.accountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;property name="transactionTemplate" ref="transactionTemplate"/&gt; &lt;/bean&gt; &lt;!-- 创建模板 --&gt; &lt;bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate"&gt; &lt;property name="transactionManager" ref="txManager"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 ,管理器需要事务，事务从Connection获得，连接从连接池DataSource获得 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 工厂bean生成代理：半自动 spring提供 管理事务的代理工厂bean TransactionProxyFactoryBean1.getBean() 获得代理对象2.spring 配置一个代理 修改配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 创建数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring_day03?useSSL=false&amp;amp;serverTimezone=UTC"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="as980702"/&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.rj.spring.Transaction.HandOf.Dao.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;bean id="accountServiceId" class="com.rj.spring.Transaction.HandOf.Service.impl.accountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4 service 代理对象 4.1 proxyInterfaces 接口 4.2 target 目标类 4.3 transactionManager 事务管理器 4.4 transactionAttributes 事务属性（事务详情） prop.key ：确定哪些方法使用当前事务配置 prop.text:用于配置事务详情 格式：PROPAGATION,ISOLATION,readOnly,-Exception,+Exception 传播行为 隔离级别 是否只读 异常回滚 异常提交 例如： &lt;prop key="transfer"&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&lt;/prop&gt; 默认传播行为，和隔离级别 &lt;prop key="transfer"&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly&lt;/prop&gt; 只读 &lt;prop key="transfer"&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT,+java.lang.ArithmeticException&lt;/prop&gt; 有异常扔提交 --&gt; &lt;bean id="proxyAccountService" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt; &lt;property name="proxyInterfaces" value="com.rj.spring.Transaction.HandOf.Service.accountService"&gt;&lt;/property&gt; &lt;property name="target" ref="accountServiceId"&gt;&lt;/property&gt; &lt;property name="transactionManager" ref="txManager"&gt;&lt;/property&gt; &lt;property name="transactionAttributes"&gt; &lt;props&gt; &lt;prop key="transfer"&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试文件 123456789101112131415161718package com.rj.spring.Transaction.HandOf.Test;import com.rj.spring.Transaction.HandOf.Service.accountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestApp &#123; @Test public void demo01()&#123; String xmlPath = "applicationContext1.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); accountService accountService = (accountService) applicationContext.getBean("proxyAccountService"); accountService.transfer("rose", "jack", 1000); &#125;&#125; AOP配置基于xml 在spring xml 配置aop 自动生成代理，进行事务的管理 配置管理器 配置事务详情 配置aop 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 创建数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring_day03?useSSL=false&amp;amp;serverTimezone=UTC"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="as980702"/&gt; &lt;/bean&gt; &lt;bean id="accountDaoId1" class="com.rj.spring.Transaction.aopXml.Dao.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;bean id="accountServiceId" class="com.rj.spring.Transaction.aopXml.Service.impl.accountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDaoId1"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 ,管理器需要事务，事务从Connection获得，连接从连接池DataSource获得 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 事务详情（事务通知） ， 在aop筛选基础上，对ABC三个确定使用什么样的事务。例如：AC读写、B只读 等 &lt;tx:attributes&gt; 用于配置事务详情（属性属性） &lt;tx:method name=""/&gt; 详情具体配置 propagation 传播行为 ， REQUIRED：必须；REQUIRES_NEW:必须是新的 isolation 隔离级别 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="transfer" propagation="REQUIRED" isolation="DEFAULT"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- AOP编程，目标类有ABCD（4个连接点），切入点表达式 确定增强的连接器，从而获得切入点：ABC --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* cn.lm.tx03_xml.*.*(..))"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; AOP配置基于注解 1.配置事务管理器，将并事务管理器交予spring 2.在目标类或目标方法添加注解即可 @Transactional service层 123456789101112131415161718192021222324252627package com.rj.spring.Transaction.aopAnno.Service.impl;import com.rj.spring.Transaction.aopAnno.Dao.AccountDao;import com.rj.spring.Transaction.aopAnno.Service.accountService;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT)public class accountServiceImpl implements accountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void transfer(String outer, String inner, int money) &#123; accountDao.out(outer, money); //断电 //int i = 1/0; accountDao.in(inner, money); &#125;&#125; 配置文件 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 创建数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring_day03?useSSL=false&amp;amp;serverTimezone=UTC"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="as980702"/&gt; &lt;/bean&gt; &lt;bean id="accountDaoId2" class="com.rj.spring.Transaction.aopAnno.Dao.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;bean id="accountServiceId" class="com.rj.spring.Transaction.aopAnno.Service.impl.accountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDaoId2"/&gt; &lt;/bean&gt; &lt;!-- 4 事务管理 --&gt; &lt;!-- 4.1 事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.2 将管理器交予spring * transaction-manager 配置事务管理器 * proxy-target-class true ： 底层强制使用cglib 代理 --&gt; &lt;tx:annotation-driven transaction-manager="txManager" /&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Service: SOAP&REST]]></title>
    <url>%2F2019%2F05%2F15%2FWeb-Service-SOAP-REST%2F</url>
    <content type="text"><![CDATA[了解Webservice Java开发WebService最重要的两个规范 JSR-224 (JAX-WS：Java API for XML-Based Web Services ) ，主要使用soap协议，使用wsdl来描述 JSR-311 (JAX-RS：The Java API for RESTful Web Services)，使用wadl描述 SOAP和REST是两种实现WebService的主要方案 REST Web Services 基于 HTTP 协议 SOAP Web Services 支持多种传输协议：HTTP、SMTP、MIME等 REST与SOAP的区别： REST为每一个资源指定一个唯一的URI，用HTTP的4种方法发送请求：GET、POST、PUT、DELETE直观地表示获取、创建、更新和删除。 SOAP仅仅使用POST方法发送请求，用一个唯一的URI标识服务的入口。（因为SOAP并不假定传输数据的下层协议，因此必须设计为能在各种协议上运行。即使绝大多数SOAP是运行在HTTP上，使用URI标识服务。这种设计被诟病之处，在于DELETE操作也要用POST方法来发送，而其实HTTP协议有更和逻辑的DELETE方法可用。） WSDL和WASL WSDL（Web Services Description Language）：网络服务描述语言是Web Service的描述语言。wsdl是在调用web服务时，由服务器发布的调用规范描述，这个描述是XML格式的用于描述Web Service及其函数、参数和返回值。因为是基于XML的，所以WSDL既是机器可阅读的， 又是人可阅读的。 WADL（Web Application Description Language）： 用基于文本的协议描述和基于XMLSchema的数据格式描述来描述应用；为了使用这种基于HTTP的web应用（尤其是使用XML进行交互的应用），WADL被设计用来提供一种机器可处理的协议描述格式。]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Web Service</tag>
        <tag>WADL</tag>
        <tag>WSDL</tag>
        <tag>SOAP</tag>
        <tag>REST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven使用笔记]]></title>
    <url>%2F2019%2F05%2F15%2FMaven%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F05%2F15%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[介绍Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 强调**这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车） 链接行内式[GitHub](http://github.com) 自动生成连接 &lt;http://www.github.com/&gt; 参考式[GitHub][1] [1]:http://github.com 自动生成连接 &lt;http://www.github.com/&gt; 自动链接&lt;http://www.github.com/&gt; 锚点: 页内超链接## 0. 目录{#index} 跳转到[目录](#index) 列表无序+ 无序列表 + 无序列表 - 无序列表 - 无序列表 * 无序列表 * 无序列表 有序1. 有序列表一 2. 有序列表二 3. 有序列表三 定义型Markdown : 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格） 列表缩进列表可以进行缩进，最多三个空格，项目标记后面则一定要接着至少一个空格或制表符。 * 列表缩进1 * 列表缩进2 包含段落的列表列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符 * 我的段落 包含引用的列表* 阅读的方法: &gt; 打开书本。 &gt; 打开电灯。 包含代码区块的列表代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符 * 我的 代码 print(&quot;Hello World&quot;); 引用&gt; 这是引用的内容 引用的多层嵌套&gt; 这是引用的内容1 &gt;&gt; 这是引用的内容2 &gt;&gt;&gt; 这是引用的内容3 引用其他要素&gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; print(&quot;Hello World&quot;); 图片![图片Alt](图片地址/图片Title.png) 分割线* * * *** --- - - - 代码区块行内式`print(&quot;hello world&quot;);` 缩进式多行代码代码前四个空格或一个制表符 用6个`包裹代码```public static void main(String[] args) { System.out.println(“Hello World!”);}``` HTML原始代码&lt;div class=&quot;footer&quot;&gt; © 2004 Foo Corporation &lt;/div&gt; 表格第一格表头 | 第二格表头 ---------| ------------- 内容单元格 第一列第一格 | 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 内容单元格 第一列第三格 多加文字 | 内容单元格第二列第三格 内容单元格 第一列第四格 多加文字 | 内容单元格第二列第四格 ps:第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。 注脚使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言 [^Le]:开源笔记平台，支持Markdown和笔记直接发为博文 反斜杠相当于反转义作用。使符号成为普通符号。 符号``标记作用 `Commond + C` 流程图```flow st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op&amp;``` ###Todo - [ ] 不勾选 - [x] 勾选]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux/Mac上的命令行]]></title>
    <url>%2F2019%2F05%2F14%2FLinux-Mac%E4%B8%8A%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[mycli - mysql命令行客户端brew update &amp;&amp; brew install mycli ccat - cat增强版 代码高亮brew install ccat thefuck - 写错命令 fuck一下brew install thefuck gcc - 编译C&amp;C++代码brew install gcc tree - 树结构显示文件树内容brew install tree pstree - 树结构显示进程树内容brew install pstree wget - 自动下载文件的自由工具brew install wget adb - 连接Android 手机brew cask install android-platform-tools 彩蛋命令sl - 小火车brew install sl toilet - 彩色显示文本brew install toilet cmatrix - 黑客帝国：矩阵brew install cmatrix]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Mac OS</tag>
        <tag>Terminal</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上git ssh配置]]></title>
    <url>%2F2019%2F05%2F14%2FMac%E4%B8%8Agit-ssh%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[查看是否已配置 cd ~/.ssh 进入ssh目录没有此目录即未配置，需重新配置 git config --list 检查是否配置过git账户 ls 查看具体内容如果ssh文件夹中有id_rsa，id_rsa.pub，说明之前生成过ssh 秘钥，可以直接使用 重新配置 配置账户 123git config --global user.name &quot;account name&quot; -&gt;用户名，建议拼音或英文git config --global user.email &quot;account email&quot; -&gt;邮箱地址 生成密钥ssh -keygen -t rsa -C &quot;account email&quot; cat id_rsa.pub 查看公有密钥，全部复制，添加到github中 Github添加SSH Key打开github-profile settings-SSH keys-Add an SSH Key，Key中粘贴刚才复制的，然后Title，里面会自动生成邮箱，点击add key完成添加，最后可以点击SSH keys 查看 MyConfig123456Host github.comUser &quot;Email&quot;Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Mac OS</tag>
        <tag>Terminal</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm + zsh]]></title>
    <url>%2F2019%2F05%2F14%2FiTerm-zsh%2F</url>
    <content type="text"><![CDATA[安装 iTerm 21brew cask install iterm2 安装完成后即可使用iterm2进行后续操作 安装 zsh1brew install zsh zsh-completions 安装 Git1brew install git 安装 Oh My Zsh1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 安装设置字体Meslo LG M Regular for Powerline 设置主题ZSH_THEME=”agnoster”/“ys” 插件语法高亮提示12git clone https://github.com/zsh-users/zsh-syntax-highlighting.git echo &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc 超强自动补全zsh-autosuggestions12345//安装git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions//配置 .zshrcplugins配置,增加zsh-autosuggestions 跳转目录 autojump brew install autojump 安装完在ZSH下不可用，需在.zshrc下添加以下命令1234567891011[[ -s brew --prefix/etc/autojump.sh ]] &amp;&amp; . brew --prefix/etc/autojump.shsource ~/.bash_profilesource /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zshX source ~/.oh-my-zsh/plugins/incr/incr*.zshexport LC\_ALL=en_US.UTF-8export LANG=en_US.UTF-8 zoh-my-zsh中自带，直接在plugins中添加 我安装的插件z gitfast zsh-autosuggestions zsh-syntax-highlighting 快捷键左右跳转按住option + → or ←键，在命令的开始和结尾跳转切换 打开 iTerm2，按Command + ,键，打开 Preferences 配置界面，然后Profiles → Keys → Load Preset… → Natural Text Editing 问题oh-my-zsh agnoster主题特殊字符显示异常问题.oh-my-zsh/themes/agnoster.zsh-theme:72: parse error near &lt;&lt;&lt; 解决方案：123cd ~/.oh-my-zsh/themesgit checkout d6a36b1 agnoster.zsh-theme 一些命令无法执行在zshrc文件中添加profle文件的支持 Mac OS1source ~/.bash_profile Ubuntu1source ~/.profile]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Mac OS</tag>
        <tag>Terminal</tag>
        <tag>iTerm2</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac + OhMyZsh + Powerlevel10k]]></title>
    <url>%2F2019%2F05%2F14%2FMac-OhMyZsh-Powerlevel10k%2F</url>
    <content type="text"><![CDATA[基本使用安装 iTerm 21brew cask install iterm2 安装完成后即可使用iterm2进行后续操作 安装 zsh1brew install zsh zsh-completions 安装 Git1brew install git 安装 Oh My Zsh1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 安装字体 Nerd-Fonts12brew tap caskroom/fonts #字体安装软件，安装之后可以安装其他字体brew cask install font-hack-nerd-font # 安装Nerd字体 iTerm 设定字体选择iTerm的配置 &gt; Profiles &gt; Text &gt; Change Font &gt; Non-ASCII 字体 — Hack Nerd Font 字体重新启动 iTerm ，字体设定完成。 进阶使用安装 Powerlevel10K 主题安装命令1git clone https://github.com/romkatv/powerlevel10k.git .oh-my-zsh/themes/powerlevel10k 设置 .zshrc 中的变量 ZSH_THEMEZSH_THEME=”powerlevel10k/powerlevel10k” 主题的设置12vim ~/.zshrcZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; 调整主题：1POWERLEVEL9K_MODE=&apos;nerdfont-complete&apos; # 设置字体 其他设置：123456789POWERLEVEL9K_ALWAYS_SHOW_USER=truePOWERLEVEL9K_CONTEXT_TEMPLATE=&quot;%n&quot;POWERLEVEL9K_PROMPT_ON_NEWLINE=truePOWERLEVEL9K_RPROMPT_ON_NEWLINE=truePOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(user dir vcs)POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status time)POWERLEVEL9K_STATUS_VERBOSE=falsePOWERLEVEL9K_MULTILINE_FIRST_PROMPT_PREFIX=&quot;&quot;POWERLEVEL9K_MULTILINE_LAST_PROMPT_PREFIX=&quot;%&#123;%b%f%k%F&#123;blue&#125;%&#125; %&#123;%f%&#125;&quot; 重启配置文件1source ~/.zshrc 超炫酷命令行设置完成！ 效果展示]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Mac OS</tag>
        <tag>Terminal</tag>
        <tag>iTerm2</tag>
        <tag>zsh</tag>
        <tag>powerlevel10k</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat - 免费的Web服务器]]></title>
    <url>%2F2019%2F05%2F13%2FTomcat-%E5%85%8D%E8%B4%B9%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[安装方式Mac OS ： brew install tomcatWindows: 推荐下载绿色版 安装路径Tomcat home: /usr/local/Cellar/tomcat/9.0.14/libexecwebapp home: /usr/local/Cellar/tomcat/9.0.14/libexec/webapps/ROOT Command运行Tomcat:$ catalina run 或者以服务方式自启动:$ brew services start tomcat 关闭服务:$ ps aux | grep tomcat$ kill -9 pid 默认端口号：8080 manager页面访问如果要访问http://localhost:8080/manager的内容，需要编辑以下文件添加用户，不添加或添加不正确会出现401以及403错误 403 Access DeniedYou are not authorized to view this page./usr/local/Cellar/tomcat/9.0.7/libexec/conf/tomcat-users.xml12345&lt;role rolename="admin"/&gt;&lt;role rolename="admin-gui"/&gt;&lt;role rolename="manager"/&gt;&lt;role rolename="manager-gui"/&gt;&lt;user username="name" password="pwd" roles="admin,admingui,manager,manager-gui"/&gt; 保存重启Tomcat后应该就能登陆显示manager页面了，如果还不行再尝试修改一下 /usr/local/Cellar/tomcat/9.0.7/libexec/webapps/manager/META-INF/context.xml1234567&lt;Context antiResourceLocking="false" privileged="true" &gt;&lt;!--注释下面内容以从允许从Tomcat安装地以外的地址访问--\&gt; &lt;!-- &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve" allow="127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1" /&gt; --&gt;&lt;Manager sessionAttributeValueClassNameFilter="java.lang.(?:Boolean|Integer|Long|Number|String)|org.apache.catalina.filters.CsrfPreventionFilter$LruCache(?:$1)?|java.util.(?:Linked)?HashMap"/&gt;&lt;/Context&gt; 修改端口/usr/local/Cellar/tomcat/9.0.14/libexec/conf/server.xml1&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8543" /&gt; 问题排查 有的时候，在server.xml 中配置的&lt;\context 是以“/”为开始路径的，与此同时，在webapps目录下还存在一个ROOT目录，这个ROOT目录其实也是告诉tomcat，以“/” 为开始路径，那么这样就发生冲突了，Tomcat只能二选一，通常情况下都会选择ROOT目录，那么在server.xml中配置的就&lt;\context 就无法启动了，导致访问对应的资源提示404错误。 解决办法就是删除掉ROOT目录，或者把ROOT目录重命名 Tomcat启动的时候会报一个Exception loading sessions from persistent storage异常 该问题的原因是tomcat的session持久化机制引起的，tomcat这个功能本身的用意在于重启tomcat后保存之前的session，Tomcat会把session持久化在%TOMCAT%/work/Catalina/localhost/session.ser 这个文件里。 但是因为tomcat非正常关闭，所以这个文件没有正确地结束(无EOF标记) 解决办法治标： 只需要删除 session.ser文件即可。 解决办法治本：关闭tomcat的持久化功能，就能一劳永逸的解决这个问题。具体为修改conf下的server.xml文件。在项目的context间加入一句代码 1&lt;Manager className="org.apache.catalina.session.PersistentManager" saveOnRestart="false"/&gt;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>我的软件</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Spring - day2]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%AD%A6%E4%B9%A0Spring-day2%2F</url>
    <content type="text"><![CDATA[AOP介绍什么是AOP AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP（面向对象编程）的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码 经典应用：事务管理、性能监视、安全检查、缓存 、日志等 Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码 AspectJ是一个基于Java语言的AOP框架，Spring2.0开始，Spring AOP引入对Aspect的支持，AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供横向代码的织入 AOP实现原理 aop底层将采用代理机制进行实现。 接口 + 实现类：spring采用 jdk 的动态代理Proxy。 实现类：spring 采用 cglib字节码增强。 AOP术语 target目标类：需要被代理的类。例如：UserService Joinpoint连接点：所谓连接点是指那些可能被拦截到的方法。例如：所有的方法 PointCut切入点：已经被增强的连接点。例如：addUser() advice通知/增强，增强代码。例如：after、before Weaving织入：是指把增强advice应用到目标对象target来创建新的代理对象proxy的过程. proxy代理类 Aspect切面：是切入点pointcut和通知advice的结合一个线是一个特殊的面。一个切入点和一个通知，组成成一个特殊的面。 手动方式JDK动态代理 JDK动态代理 对“装饰者”设计模式 简化。使用前提：必须有接口1.目标类：接口 + 实现类 123456789101112131415161718192021222324252627package com.rj.spring.aop.jdkTest;public interface UserService &#123; public void addUser(); public void updateUser(); public void deleteUser();&#125;package com.rj.spring.aop.jdkTest;public class UserServiceImp implements UserService&#123; @Override public void addUser() &#123; System.out.println(" 添加了一个用户"); &#125; @Override public void updateUser() &#123; System.out.println(" 更新了一个用户"); &#125; @Override public void deleteUser() &#123; System.out.println(" 删除了一个用户"); &#125;&#125; 2.切面类：用于存通知 MyAspect 123456789101112package com.rj.spring.aop.jdkTest;public class MyAspect &#123; public void before()&#123; System.out.println("----之前----"); &#125; public void after()&#123; System.out.println("----之后----"); &#125;&#125; 3.工厂类：编写工厂生成代理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.rj.spring.aop.jdkTest;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class MyBeanFactory &#123; public static UserService createUserService() &#123; //1. 目标类 final UserService userService = new UserServiceImp(); //2. 切面类 final MyAspect myAspect = new MyAspect(); /* * 3. 代理类：将目标类（切入点 ）和 切面类（通知） 结合 --&gt; 切面 * Proxy.newProxyInstance * 参数1：loader ，类加载器，动态代理类 运行时创建，任何类都需要类加载器将其加载到内存。 * 一般情况：当前类.class.getClassLoader(); * 目标类实例.getClass().get... * 参数2：Class[] interfaces 代理类需要实现的所有接口 * 方式1：目标类实例.getClass().getInterfaces() ;注意：只能获得自己接口，不能获得父元素接口 * 方式2：new Class[]&#123;UserService.class&#125; * 例如：jdbc 驱动 --&gt; DriverManager 获得接口 Connection * 参数3：InvocationHandler 处理类，接口，必须进行实现类，一般采用匿名内部 * 提供 invoke 方法，代理类的每一个方法执行时，都将调用一次invoke * 参数31：Object proxy ：代理对象 * 参数32：Method method : 代理对象当前执行的方法的描述对象（反射） * 执行方法名：method.getName() * 执行方法：method.invoke(对象，实际参数) * 参数33：Object[] args :方法实际参数 * */ UserService proxService = (UserService) Proxy.newProxyInstance( MyBeanFactory.class.getClassLoader(), userService.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; myAspect.before(); Object obj = method.invoke(userService, args); myAspect.after(); return obj; &#125; &#125;); return proxService; &#125;&#125; 4.测试 12345678910111213package com.rj.spring.aop.jdkTest;public class Test &#123; @org.junit.Test public void Demo01()&#123; UserService userService = MyBeanFactory.createUserService(); userService.addUser(); userService.updateUser(); userService.deleteUser(); &#125;&#125; CGLIB字节码增强 没有接口，只有实现类。 采用字节码增强框架cglib，在运行时创建目标类的子类，从而对目标类进行增强。 导入jar包：spring-core.jar 1.实现类12345678910111213141516package com.rj.spring.aop.cglibTest;public class UserServiceImp &#123; public void addUser() &#123; System.out.println(" 添加了一个用户"); &#125; public void updateUser() &#123; System.out.println(" 更新了一个用户"); &#125; public void deleteUser() &#123; System.out.println(" 删除了一个用户"); &#125;&#125; 2.切面类123456789101112package com.rj.spring.aop.cglibTest;public class MyAspect &#123; public void before()&#123; System.out.println("----之前----"); &#125; public void after()&#123; System.out.println("----之后----"); &#125;&#125; 3.代理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.rj.spring.aop.cglibTest;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class MyBeanFactory &#123; public static UserServiceImp createUserService() &#123; //1. 目标类 final UserServiceImp userService = new UserServiceImp(); //2. 切面类 final MyAspect myAspect = new MyAspect(); // 3.代理类 ，采用cglib，底层创建目标类的子类 //3.1 核心类 Enhancer enhancer = new Enhancer(); //3.2 确定父类 enhancer.setSuperclass(userService.getClass()); /* 3.3 设置回调函数 , MethodInterceptor接口 等效 jdk InvocationHandler接口 * intercept() 等效 jdk invoke() * 参数1、参数2、参数3：以invoke一样 * 参数4：methodProxy 方法的代理 */ enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; //前 myAspect.before(); //执行目标类的方法 Object obj = method.invoke(userService, args); // * 执行代理类的父类 ，执行目标类 （目标类和代理类 父子关系） methodProxy.invokeSuper(proxy, args); //后 myAspect.after(); return obj; &#125; &#125;); //3.4 创建代理 UserServiceImp proxService = (UserServiceImp) enhancer.create(); return proxService; &#125;&#125; 4.测试12345678910111213package com.rj.spring.aop.cglibTest;public class Test &#123; @org.junit.Test public void Demo01()&#123; UserServiceImp userService = MyBeanFactory.createUserService(); userService.addUser(); userService.updateUser(); userService.deleteUser(); &#125;&#125; AOP联盟通知类型 AOP联盟为通知Advice定义了org.aopalliance.aop.Advice Spring按照通知Advice在目标类方法的连接点位置，可以分为5类• 前置通知 org.springframework.aop.MethodBeforeAdvice• 在目标方法执行前实施增强• 后置通知 org.springframework.aop.AfterReturningAdvice• 在目标方法执行后实施增强• 环绕通知 org.aopalliance.intercept.MethodInterceptor• 在目标方法执行前后实施增强• 异常抛出通知 org.springframework.aop.ThrowsAdvice• 在方法抛出异常后实施增强• 引介通知 org.springframework.aop.IntroductionInterceptor• 在目标类中添加一些新的方法和属性 12345678//环绕通知，必须手动执行目标方法try&#123; //前置通知 //执行目标方法 //后置通知&#125; catch()&#123; //抛出异常通知&#125; Spring编写代理：自动方法导入jar包： 四个核心 + aop + aop联盟1.实现类123456789101112131415161718192021222324252627package com.rj.spring.aop.factoryBean;public interface UserService &#123; public void addUser(); public void updateUser(); public void deleteUser();&#125;package com.rj.spring.aop.factoryBean;public class UserServiceImp implements UserService &#123; @Override public void addUser() &#123; System.out.println(" 添加了一个用户"); &#125; @Override public void updateUser() &#123; System.out.println(" 更新了一个用户"); &#125; @Override public void deleteUser() &#123; System.out.println(" 删除了一个用户"); &#125;&#125; 2.切面类12345678910111213141516171819202122232425package com.rj.spring.aop.factoryBean;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;public class MyAspect implements MethodInterceptor &#123; public void before()&#123; System.out.println("----之前----"); &#125; public void after()&#123; System.out.println("----之后----"); &#125; @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123; before(); //手动执行目标方法 methodInvocation.proceed(); after(); return null; &#125;&#125; 3.xml实现代理12345678910111213141516171819202122232425262728293031&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="userServiceId" class="com.rj.spring.aop.factoryBean.UserServiceImp"&gt;&lt;/bean&gt; &lt;bean id="myAspectId" class="com.rj.spring.aop.factoryBean.MyAspect"&gt;&lt;/bean&gt; &lt;!-- 创建代理类 * 使用工厂bean FactoryBean ，底层调用 getObject() 返回特殊bean * ProxyFactoryBean 用于创建代理工厂bean，生成特殊代理对象 interfaces : 确定接口们 通过&lt;array&gt;可以设置多个值 只有一个值时，value="" target : 确定目标类 interceptorNames : 通知 切面类的名称，类型String[]，如果设置一个值 value="" optimize :强制使用cglib &lt;property name="optimize" value="true"&gt;&lt;/property&gt; 底层机制 如果目标类有接口，采用jdk动态代理 如果没有接口，采用cglib 字节码增强 如果声明 optimize = true ，无论是否有接口，都采用cglib --&gt; &lt;bean id="proxyServiceId" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="interfaces" value="com.rj.spring.aop.factoryBean.UserService"&gt;&lt;/property&gt; &lt;property name="target" ref="userServiceId"&gt;&lt;/property&gt; &lt;property name="interceptorNames" value="myAspectId"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.测试1234567891011121314151617181920package com.rj.spring.aop.factoryBean;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; @org.junit.Test public void Demo01()&#123; String xmlPath = "com/rj/spring/aop/factoryBean/MySpring.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); UserService userService = (UserService) applicationContext.getBean("proxyServiceId"); userService.addUser(); userService.updateUser(); userService.deleteUser(); &#125;&#125; Spring aop编程：全自动方法 导入jar包：aspectj.weaver1.实现类和2.切面类与上文一样 3.xml实现代理1234567891011121314151617181920212223242526272829303132&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="userServiceId" class="com.rj.spring.aop.springAop.UserServiceImp"&gt;&lt;/bean&gt; &lt;bean id="myAspectId" class="com.rj.spring.aop.springAop.MyAspect"&gt;&lt;/bean&gt; &lt;!-- 3 aop编程 3.1 导入命名空间 3.2 使用 &lt;aop:config&gt;进行配置 proxy-target-class="true" 声明时使用cglib代理 &lt;aop:pointcut&gt; 切入点 ，从目标对象获得具体方法 &lt;aop:advisor&gt; 特殊的切面，只有一个通知 和 一个切入点 advice-ref 通知引用 pointcut-ref 切入点引用 3.3 切入点表达式 execution(* com.itheima.c_spring_aop.*.*(..)) 选择方法 返回值任意 包 类名任意 方法名任意 参数任意 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="MypiontCut" expression="execution(* com.rj.spring.aop.springAop.*.*(..))"/&gt; &lt;aop:advisor advice-ref="myAspectId" pointcut-ref="MypiontCut"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4.测试1234567891011@org.junit.Testpublic void Demo01()&#123; String xmlPath = "com/rj/spring/aop/springAop/MySpring.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); UserService userService = (UserService) applicationContext.getBean("userServiceId"); userService.addUser(); userService.updateUser(); userService.deleteUser();&#125; AspectJAspectJ介绍 AspectJ是一个基于Java语言的AOP框架 Spring2.0以后新增了对AspectJ切点表达式支持 @AspectJ 是AspectJ1.5新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面新版本Spring框架，建议使用AspectJ方式来开发AOP 主要用途：自定义开发 切入点表达式 execution 123456789101112131415161718192021222324252627282930execution() 用于描述方法 【掌握】 语法：execution(修饰符 返回值 包.类.方法名(参数) throws异常) 修饰符，一般省略 public 公共方法 * 任意 返回值，不能省略 void 返回没有值 String 返回值字符串 * 任意 包，[省略] com.rj.crm 固定包 com.rj.crm.*.service crm包下面子包任意 （例如：com.rj.crm.staff.service） com.rj.crm.. crm包下面的所有子包（含自己） com.rj.crm.*.service.. crm包下面任意子包，固定目录service，service目录任意包 类，[省略] UserServiceImpl 指定类 *Impl 以Impl结尾 User* 以User开头 * 任意 方法名，不能省略 addUser 固定方法 add* 以add开头 *Do 以Do结尾 * 任意 (参数) () 无参 (int) 一个整型 (int ,int) 两个 (..) 参数任意 throws ,可省略，一般不写。 within: 匹配包或者子包中的方法 this: 匹配实现接口的代理对象中的方法 target: 匹配实现接口的目标对象中的方法 args: 陪陪参数格式符合标准的方法 bean(id): 对指定的bean所有的方法 AspectJ通知类型 aop联盟定义通知类型，具有特性接口，必须实现，从而确定方法名称。 aspectj 通知类型，只定义类型名称。已经方法格式。 个数：6种，知道5种，掌握1中。 before:前置通知(应用：各种校验)在方法执行前执行，如果通知抛出异常，阻止方法运行 afterReturning:后置通知(应用：常规数据处理)方法正常返回后执行，如果方法中抛出异常，通知无法执行 必须在方法执行后才执行，所以可以获得方法的返回值。 around:环绕通知(应用：十分强大，可以做任何事情)方法执行前后分别执行，可以阻止方法的执行 必须手动执行目标方法 afterThrowing:抛出异常通知(应用：包装异常信息)方法抛出异常后执行，如果方法没有抛出异常，无法执行 after:最终通知(应用：清理现场)方法执行完毕后执行，无论方法中是否出现异常 1234567891011//环绕try&#123; //前置：before //手动执行目标方法 //后置：afterRetruning&#125; catch()&#123; //抛出异常 afterThrowing&#125; finally&#123; //最终 after&#125; 导入jar包 aop联盟规范 —– aopalliance spring aop 实现 —– spring-aop aspect 规范 —– aspectj.weaver spring aspect 实现 —– aspects 基于XML1.目标类：接口 + 实现 2.切面类：编写多个通知，采用aspectj 通知名称任意（方法名任意）123456789101112131415161718192021222324252627282930313233package com.rj.spring.aspectTest.xmlTest;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;public class MyAspect &#123; public void myBefore(JoinPoint joinPoint)&#123; System.out.println("前置通知 ： " + joinPoint.getSignature().getName()); &#125; public void myAfterReturning(JoinPoint joinPoint,Object ret)&#123; System.out.println("后置通知 ： " + joinPoint.getSignature().getName() + " , --&gt;" + ret); &#125; public Object myAround(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println("前"); //手动执行目标方法 Object obj = joinPoint.proceed(); System.out.println("后"); return obj; &#125; public void myAfterThrowing(JoinPoint joinPoint,Throwable e)&#123; System.out.println("抛出异常通知 ： " + e.getMessage()); &#125; public void myAfter(JoinPoint joinPoint)&#123; System.out.println("最终通知"); &#125;&#125; 3.aop编程，将通知应用到目标类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="userServiceId" class="com.rj.spring.aspectTest.xmlTest.UserServiceImp"&gt;&lt;/bean&gt; &lt;bean id="myAspectId" class="com.rj.spring.aspectTest.xmlTest.MyAspect"&gt;&lt;/bean&gt; &lt;!-- 3 aop编程 &lt;aop:aspect&gt; 将切面类 声明“切面”，从而获得通知（方法） ref 切面类引用 &lt;aop:pointcut&gt; 声明一个切入点，所有的通知都可以使用。 expression 切入点表达式 id 名称，用于其它通知引用 --&gt; &lt;aop:config&gt; &lt;aop:aspect ref="myAspectId"&gt; &lt;aop:pointcut expression="execution(* com.rj.spring.aspectTest.xmlTest.UserServiceImp.*(..))" id="myPointCut"/&gt; &lt;!-- 3.1 前置通知 &lt;aop:before method="" pointcut="" pointcut-ref=""/&gt; method : 通知，及方法名 pointcut :切入点表达式，此表达式只能当前通知使用。 pointcut-ref ： 切入点引用，可以与其他通知共享切入点。 通知方法格式：public void myBefore(JoinPoint joinPoint)&#123; 参数1：org.aspectj.lang.JoinPoint 用于描述连接点（目标方法），获得目标方法名等 例如： &lt;aop:before method="myBefore" pointcut-ref="myPointCut"/&gt; --&gt; &lt;!-- 3.2后置通知 ,目标方法后执行，获得返回值 &lt;aop:after-returning method="" pointcut-ref="" returning=""/&gt; returning 通知方法第二个参数的名称 通知方法格式：public void myAfterReturning(JoinPoint joinPoint,Object ret)&#123; 参数1：连接点描述 参数2：类型Object，参数名 returning="ret" 配置的 例如： &lt;aop:after-returning method="myAfterReturning" pointcut-ref="myPointCut" returning="ret" /&gt; --&gt; &lt;!-- 3.3 环绕通知 &lt;aop:around method="" pointcut-ref=""/&gt; 通知方法格式：public Object myAround(ProceedingJoinPoint joinPoint) throws Throwable&#123; 返回值类型：Object 方法名：任意 参数：org.aspectj.lang.ProceedingJoinPoint 抛出异常 执行目标方法：Object obj = joinPoint.proceed(); 例如： &lt;aop:around method="myAround" pointcut-ref="myPointCut"/&gt; --&gt; &lt;!-- 3.4 抛出异常 &lt;aop:after-throwing method="" pointcut-ref="" throwing=""/&gt; throwing ：通知方法的第二个参数名称 通知方法格式：public void myAfterThrowing(JoinPoint joinPoint,Throwable e)&#123; 参数1：连接点描述对象 参数2：获得异常信息，类型Throwable ，参数名由throwing="e" 配置 例如： &lt;aop:after-throwing method="myAfterThrowing" pointcut-ref="myPointCut" throwing="e"/&gt; --&gt; &lt;!-- 3.5 最终通知 --&gt; &lt;aop:after method="myAfter" pointcut-ref="myPointCut"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4.测试同上 基于注解 目标类同上 切面类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.rj.spring.aspectTest.annoTest;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Component@Aspectpublic class MyAspect &#123; //切入点当前有效 //@Before("com.rj.spring.aspectTest.annoTest.UserServiceImp.*(..))") public void myBefore(JoinPoint joinPoint)&#123; System.out.println("前置通知 ： " + joinPoint.getSignature().getName()); &#125; //声明公共切入点 @Pointcut("execution(* com.rj.spring.aspectTest.annoTest.UserServiceImp.*(..))") private void myPointCut()&#123; &#125; //@AfterReturning(value="myPointCut()" ,returning="ret") public void myAfterReturning(JoinPoint joinPoint,Object ret)&#123; System.out.println("后置通知 ： " + joinPoint.getSignature().getName() + " , --&gt;" + ret); &#125; //@Around(value = "myPointCut()") public Object myAround(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println("前"); //手动执行目标方法 Object obj = joinPoint.proceed(); System.out.println("后"); return obj; &#125; //@AfterThrowing(value="execution(* com.itheima.d_aspect.b_anno.UserServiceImpl.*(..))" ,throwing="e") public void myAfterThrowing(JoinPoint joinPoint,Throwable e)&#123; System.out.println("抛出异常通知 ： " + e.getMessage()); &#125; @After("myPointCut()") public void myAfter(JoinPoint joinPoint)&#123; System.out.println("最终通知"); &#125;&#125; 配置文件部分 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 1.扫描 注解类 --&gt; &lt;context:component-scan base-package="com.rj.spring.aspectTest.annoTest"&gt;&lt;/context:component-scan&gt; &lt;!-- 2.确定 aop注解生效 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 测试同上 aop注解的总结@Aspect 声明切面，修饰切面类，从而获得 通知。通知 @Before 前置 @AfterReturning 后置 @Around 环绕 @AfterThrowing 抛出异常 @After 最终切入点 @PointCut ，修饰方法 private void xxx(){} 之后通过“方法名”获得切入点引用 JdbcTemplate spring 提供用于操作JDBC工具类，类似：DBUtils。 依赖 连接池DataSource （数据源） 环境搭建 创建表 12345678910create database spring_day02;use spring_day02;create table t_user( id int primary key auto_increment, username varchar(50), password varchar(32));insert into t_user(username,password) values(&apos;jack&apos;,&apos;1234&apos;);insert into t_user(username,password) values(&apos;rose&apos;,&apos;5678&apos;); 导入jar包这里采用Maven进行项目管理 123456789101112131415161718192021222324252627282930313233343536373839&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/commons-dbcp/commons-dbcp --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-pool/commons-pool --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/c3p0/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;3.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; javeBean 1234567891011121314151617181920212223242526272829303132public class User &#123; private Integer id; private String username; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 使用api1234567891011121314151617181920212223242526package com.rj.spring.jdbc.normal;import org.apache.commons.dbcp.BasicDataSource;import org.springframework.jdbc.core.JdbcTemplate;public class TestNormal &#123; public static void main(String[] args) &#123; //1 创建数据源（连接池） dbcp BasicDataSource dataSource = new BasicDataSource(); // * 基本4项 dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring_day02?useSSL=false&amp;serverTimezone=UTC&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;******&quot;); //2 创建模板 JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); //3 通过api操作 jdbcTemplate.update(&quot;insert into t_user(username,password) values(?,?);&quot;, &quot;tom&quot;, &quot;998&quot;); &#125;&#125; 配置DBCP1234567891011121314151617181920&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dataSourceId&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring_day02?useSSL=false&amp;amp;serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;*****&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplateId&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSourceId&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;UserDaoId&quot; class=&quot;com.rj.spring.jdbc.dhcp.UserDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplateId&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试：12345678910111213141516package com.rj.spring.jdbc.dhcp;import org.springframework.jdbc.core.JdbcTemplate;public class UserDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; public void update()&#123; jdbcTemplate.update(&quot;insert into t_user(username,password) values(?,?);&quot;, &quot;tom&quot;, &quot;998&quot;); &#125;&#125; 配置C3P0123456789101112131415161718192021&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dataSourceId&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/spring_day02?useSSL=false&amp;amp;serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;*****&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplateId&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSourceId&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;UserDaoId&quot; class=&quot;com.rj.spring.jdbc.c3p0.UserDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplateId&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 使用JdbcDaoSupport123456789import org.springframework.jdbc.core.support.JdbcDaoSupport;public class UserDao extends JdbcDaoSupport &#123; public void update()&#123; this.getJdbcTemplate().update(&quot;insert into t_user(username,password) values(?,?);&quot;, &quot;tom&quot;, &quot;998&quot;); // &#125;&#125; 123456&lt;!-- 配置dao * dao 继承 JdbcDaoSupport，之后只需要注入数据源，底层将自动创建模板 --&gt; &lt;bean id=&quot;userDaoId&quot; class=&quot;com.rj.spring.jdbc.c3p0.UserDao&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSourceId&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 配置properties文件12345\\jdbc.propertiesjdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/spring_day02?useSSL=false&amp;serverTimezone=UTCjdbc.user=rootjdbc.password=1234 12345&lt;!-- 加载配置文件 &quot;classpath:&quot;前缀表示 src下 在配置文件之后通过 $&#123;key&#125; 获得内容--&gt;&lt;context:property-placeholder location=&quot;classpath:com/rj/properties/jdbcInfo.properties&quot;/&gt;]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用程序员的思维看漫威]]></title>
    <url>%2F2019%2F05%2F12%2F%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E7%9C%8B%E6%BC%AB%E5%A8%81%2F</url>
    <content type="text"><![CDATA[漫威宇宙其实也就讲了一件事。整个宇宙就好比一个git项目，其中有一群叫做美国队长，钢铁侠，惊奇队长，浩克，索尔等人在维护这个项目，兢兢业业的修理bug。某一天出现了一个天才程序员，叫灭霸，也在这个项目中开发，他意识到，这个项目已经很庞大了，光是编译都要几个小时，运行起来负重累累，而服务器资源就这么有限，老板又不给买机器，如果一直继续这么开发下去，这个项目迟早要出现网P0事故的，于是下定决定要把这个项目用面向对象，提取重复代码，业务拆分，算法优化等手段，彻底优化，目标是代码量减少50%。美国队长的项目组叫复仇者联盟，发现了灭霸程序员的想法后，阻止并警告灭霸说，：不要轻易去改老代码！！，很容易出bug的，代码能跑就行！！！然而，这名叫灭霸的程序员兢兢业业，取得了公司5位大股东的支持，带领团队996加班1个月，实现代码量减少50%，项目运行起来身轻如燕。因为代码量减少了很多，万恶的资本主义也开始了大裁员，星爵项目组，蜘蛛侠，猩红女巫，就连拥有博士学位的奇异博士也被裁员了。大裁员之后，美国队长为首的项目组，强忍悲伤，面对生活，继续开发修理bug，但是像雷神索尔，因为不满意公司的做法，开始磨洋工，上班就打游戏喝饮料，等着被公司裁拿补偿金。有一天一个叫蚁人的码农，找到了美国队长说，回退是不可能回退的了，但是我们可以把以前的老代码重新merge到master上来呀。美国队长作为项目组的组长，想到以前的同事失业，内心很愧疚，于是偷偷摸摸兵分五路请5位大股东喝酒吃饭，威逼利诱，拿到了现网服务器账号！代码成功回退，很多之前失业的员工被返聘，像蜘蛛侠，外包团队瓦坎达等。灭霸发现之后，大怒道，你们这群沉迷老技术的稳定派，我要把整个项目用scala重构，让你们这群渣渣程序员都失业！最后，灭霸由于太过激进，在项目中屡次采用新技术，现网屡出事故，项目灭霸的重构项目组被董事会辞退。]]></content>
      <categories>
        <category>看电影</category>
      </categories>
      <tags>
        <tag>漫威</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Windows程序清单]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%88%91%E7%9A%84Windows%E7%A8%8B%E5%BA%8F%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[日常使用浏览器 Google chrome浏览器 、360极速浏览器 压缩工具 Bandizip 杀毒软件 火绒安全软件（使用习惯好的人且使用win10可以不装） 输入法 QQ拼音 or 搜狗拼音 播放器 qq影音 / kmplayer / Potplayer 即时通讯 Tim\QQ 微信 替代记事本 Notepad++ PDF阅读 福昕阅读器 \ PDF Adobe Acrobat 笔记同步 印象笔记 \ 微软OneNote 邮件 Foxmail \ 网易邮箱大师 转换格式 格式工厂 桌面美化： 任务栏透明软件 TranslucentTB 桌面整理 腾讯电脑管家-桌面整理(单文件) 提高效率截图 Snipaste 搜索软件 everything Windows上的Spotlight Listary \ Wow 优化清理工具集 Dism++ 特别推荐爱奇艺 UWPbilibili UWP]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>我的软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Mac程序清单]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%88%91%E7%9A%84Mac%E7%A8%8B%E5%BA%8F%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[XcodeAnacodaWPS officeVPN PlusWebStormVMware FusionUltraEditTotal Video Converter liteTickeysThe UnarchiverSublime Text3starUMLShadowSocksX-NGRQuiverQQ音乐QQPycharmPopClipPolarr PhotoPlistEdit ProPixelmator ProPhpStormPDFelement 6 proParallels DesktopNoizioNightOwlNewFileMenuNavicat PremiumMovistMotrixMindNodeMicrosoft OfficeMate TranslatemaipoMagentLyicsXLICEcapiTermiStat MenusIntelliJ IDEAIINAHandShakerGoogle ChromeFruitJuiceFolx proFirefoxFileZillaEclipseDuplicate File DoctorDownloaderDisk GraphDisk DrillDashConvert-Audio ConverterClioncleanMyMac XCHM ReaderCharlesBeyond CompareBartender3ArcSoft Photo+Alfred 3优酷印象笔记休息一下微信网易云音乐腾讯视频看图截图服务器爱奇艺 Home-brew ~ ⮀ brew list slmycli sqliteccat mysql thefuckcmake node toiletcmatrix openssl tomcattreephpgcc pstreewgetzsh-syntax-highlightingredishighlight ~ ⮀ brew cask listbrooklyn qlcolorcode qlmarkdown qlstephen quicklook-json]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>我的软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Mybatis - day1]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%AD%A6%E4%B9%A0Mybatis-day1%2F</url>
    <content type="text"><![CDATA[Mybatis介绍MyBatis本是apache的一个开源项目iBatis,2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 Mybatis架构 1、 mybatis配置SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。 2、 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂 3、 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。 4、 mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。 5、 Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。 6、 Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。 7、 Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 JDBC的缺点JDBC编程步骤1、 加载数据库驱动2、 创建并获取数据库链接3、 创建jdbc statement对象4、 设置sql语句5、 设置sql语句中的参数(使用preparedStatement)6、 通过statement执行sql并获取结果7、 对sql执行结果进行解析处理8、 释放资源(resultSet、preparedstatement、connection) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//JDBC程序public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; // 加载数据库驱动 Class.forName("com.mysql.jdbc.Driver"); // 通过驱动管理类获取数据库链接 connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8", "root", "root"); // 定义sql语句 ?表示占位符 String sql = "select * from user where username = ?"; // 获取预处理statement preparedStatement = connection.prepareStatement(sql); // 设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, "王五"); // 向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); // 遍历查询结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString("id") + " " + resultSet.getString("username")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放资源 if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (preparedStatement != null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDBC问题1、 数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。 2、 Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。 3、 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。 4、 对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 Mybatis 解决JDBC缺点1、 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。解决：在SqlMapConfig.xml中配置数据连接池，使用连接池管理数据库链接。 2、 Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。 3、 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。 4、 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。 mybatis与hibernate不同Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 入门程序环境搭建1. 创建Java工程2. 导入Jar包（核心，依赖，数据库）3. 加入配置文件 a. 创建资源文件夹（Source Folder） config b. 加入log4j.properties (默认使用log4j作为输出日志） c. SqlMapConfig.xml (核心配置文件）4. 创建pojo ps：用于sql映射，pojo类通常与数据库表对应5. sql映射文件 ps：config/sqlmp下创建6. 加载映射文件 12345678910111213141516171819202122232425262728//name: SqlMapConfig.xml//path: config/SqlMapConfig.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;serverTimezone=UTC" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="as980702" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789//name: log4j.properties//path: congig/log4j.properties# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//name: User.java//path: src/ccut/rj/pojo/User.javapackage ccut.rj.pojo;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; /** * */ private static final long serialVersionUID = 1L; private Integer id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", sex=" + sex + ", birthday=" + birthday + ", address=" + address + "]"; &#125;&#125; 1234567891011121314151617//name: User.xml//path: config/sqlmap/User.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="test"&gt; &lt;!-- id:statement的id 或者叫做sql的id--&gt; &lt;!-- parameterType:声明输入参数的类型 --&gt; &lt;!-- resultType:声明输出结果的类型，应该填写pojo的全路径 --&gt; &lt;!-- #&#123;&#125;：输入参数的占位符，相当于jdbc的？ --&gt; &lt;select id="queryUserById" parameterType="int" resultType="ccut.rj.pojo.User"&gt; SELECT * FROM `user` WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试程序测试程序步骤： 1. 创建SqlSessionFactoryBuilder对象 2. 加载SqlMapConfig.xml配置文件 3. 创建SqlSessionFactory对象 4. 创建SqlSession对象 5. 执行SqlSession对象执行查询，获取结果User 6. 打印结果 7. 释放资源 123456789101112131415161718192021222324252627282930313233343536373839404142//name: MybatisTest.java//name: src/ccut/rj/junit/MybatisTest.javapublic class MybatisTest &#123; private SqlSessionFactory sqlSessionFactory = null; @Before public void init() throws Exception &#123; // 1. 创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2. 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); // 3. 创建SqlSessionFactory对象 this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testQueryUserById() throws Exception &#123; // 4. 创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行查询，获取结果User // 第一个参数是User.xml的statement的id，第二个参数是执行sql需要的参数； Object user = sqlSession.selectOne("queryUserById", 1); // 6. 打印结果 System.out.println(user); // 7. 释放资源 sqlSession.close(); &#125;&#125; #{}和${}#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 ${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。 parameterType和resultTypeparameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中 selectOne和selectListselectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常： org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3 at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70) selectList可以查询一条或多条记录。 ####SqlSessionFactoryBuilder SqlSessionFactoryBuilder用于创建SqlSessionFacoty，SqlSessionFacoty一旦创建完成就不需要SqlSessionFactoryBuilder了，因为SqlSession是通过SqlSessionFactory创建的。所以可以将SqlSessionFactoryBuilder当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。 SqlSessionFactorySqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法，SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理SqlSessionFactory。 SqlSessionSqlSession是一个面向用户的接口，sqlSession中定义了数据库操作方法。 每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。 打开一个 SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。如下： SqlSession session = sqlSessionFactory.openSession(); try{ // do work } finally { session.close(); } SqlSession中封装了对数据库的操作，如：查询、插入、更新、删除等。SqlSession通过SqlSessionFactory创建。SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。 原始Dao开发开发实例12345678910User.xml 添加&lt;!-- namespace：命名空间，用于隔离sql，还有一个很重要的作用，后面会讲 --&gt;&lt;mapper namespace="test"&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id="queryUserById" parameterType="int" resultType="ccut.rj.pojo.User"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 1234567//Dao接口//name: UserDao.java//path: src/ccut/rj/dao/UserDao.javapublic interface UserDao &#123; User queryUserById(int id);&#125; 12345678910111213141516171819202122232425//Dao实现类//name: UserDaoImp.java//path: src/ccut/rj/dao/UserDaoImp.javapublic class UserDaoImpl implements UserDao &#123; private SqlSessionFactory sqlSessionFactory; public UserDaoImpl(SqlSessionFactory sqlSessionFactory) &#123; super(); this.sqlSessionFactory = sqlSessionFactory; &#125; @Override public User queryUserById(int id) &#123; // 创建SqlSession SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 执行查询逻辑 User user = sqlSession.selectOne("queryUserById", id); // 释放资源 sqlSession.close(); return user; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334//Dao测试类//name: UserDaoTest.java//path: src/ccut/rj/junit/UsrDaoTest.javapublic class UserDaoTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; // 创建SqlSessionFactoryBuilder SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); // 创建SqlsessionFactory this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testQueryUserById() &#123; // 创建DAO UserDao userDao = new UserDaoImpl(this.sqlSessionFactory); // 执行查询 User user = userDao.queryUserById(1); System.out.println(user); &#125;&#125; 问题原始Dao开发中存在以下问题： u Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数据库操作方法 u 调用sqlSession的数据库操作方法需要指定statement的id，这里存在硬编码，不得于开发维护。 Mapper动态代理开发要求Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper接口开发需要遵循以下规范： 1、 Mapper.xml文件中的namespace与mapper接口的类路径相同。 2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 实例12345678910111213141516171819//name：UserMapper.xml//path: config/mapper/UserMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace：命名空间，用于隔离sql --&gt;&lt;!-- 还有一个很重要的作用，使用动态代理开发DAO，1. namespace必须和Mapper接口类路径一致 --&gt;&lt;mapper namespace="ccut.rj.mapper.UserMapper"&gt; &lt;!-- 根据用户id查询用户 --&gt; &lt;!-- 2. id必须和Mapper接口方法名一致 --&gt; &lt;!-- 3. parameterType必须和接口方法参数类型一致 --&gt; &lt;!-- 4. resultType必须和接口方法返回值类型一致 --&gt; &lt;select id="queryUserById" parameterType="int" resultType="ccut.rj.pojo.User"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 12345678//name: UsrMapper//path: src/ccut/rj/mapper/UserMapper.javapublic interface UserMapper &#123; User queryUserById(int id);&#125; 123456//注册到 SqlMapConfig.xml&lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml" /&gt; &lt;mapper resource="mapper/UserMapper.xml" /&gt; &lt;/mappers&gt; 123456789101112131415161718192021222324252627282930313233//测试代码//name: UserMapperTest.java//path: src/ccut/rj/junit/UserMapperTest.javapublic class UserMapperTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; // 创建SqlSessionFactoryBuilder SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml"); // 创建SqlsessionFactory this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testQueryUserById() &#123; // 获取sqlSession，和spring整合后由spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 从sqlSession中获取Mapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 执行查询方法 User user = userMapper.queryUserById(1); System.out.println(user); // 和spring整合后由spring管理 sqlSession.close(); &#125;&#125; selectOne和selectList动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。 namespacemybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。 SqlMapConfig.xml配置内容SqlMapConfig.xml中配置的内容和顺序如下： properties（属性）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境集合属性对象）environment（环境子属性对象）transactionManager（事务管理）dataSource（数据源）mappers（映射器） properties12345678propertiesdb.properties配置文件内容如下：jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root 1234567&lt;!-- 是用resource属性加载外部配置文件 --&gt; &lt;properties resource="db.properties"&gt; &lt;!-- 在properties内部用property定义属性 --&gt; &lt;!-- 如果外部配置文件有该属性，则内部定义属性被外部属性覆盖 --&gt; &lt;property name="jdbc.username" value="root123" /&gt; &lt;property name="jdbc.password" value="root123" /&gt; &lt;/properties&gt; typeAliases1. 支持别名 2. 自定义别名 123456789&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias="user" type="ccut.rj.pojo.User" /&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（大小写不敏感） --&gt; &lt;package name="ccut.rj.pojo" /&gt; &lt;package name="其它包" /&gt;&lt;/typeAliases&gt;&lt;!-- 在mapper.xml配置文件中，就可以使用设置的别名了 别名大小写不敏感 --&gt; mappers（映射器）Mapper配置的几种方法：1. \&lt;mapper resource=” “ />使用相对于类路径的资源（现在的使用方式） 如：\&lt;mapper resource=”sqlmap/User.xml” /> 2. \&lt;mapper class=” “ />使用mapper接口类路径 如：\&lt;mapper class=”cn.itcast.mybatis.mapper.UserMapper”/> 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 3. \&lt;package name=””/>注册指定包下的所有mapper接口 如：\&lt;package name=”cn.itcast.mybatis.mapper”/>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 输入映射和输出映射环境准备 拷贝项目 SqlMapConfig.xml配置文件。Mapper映射器只保留包扫描的方式 输入类型 parameterType 简单类型使用#{}占位符，或者${}进行sql拼接 pojo对象Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。 pojo包装对象开发中通过可以使用pojo传递查询条件。查询条件可能是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如查询用户信息的时候，将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。包装对象：Pojo类中的一个属性是另一个pojo。 实例 编写包装类 sql语句 Mapper.xml文件 tips: #{}或者${}括号中的值为被包装pojo的属性名称，比如${user.username} Mapper接口 测试 效果 输出类型resultType 简单类型 pojo对象 pojo列表 写pojo类型就OK resultMap例子：如代码块所示 对比：resultType可以指定将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系，resultMap实质上还需要将查询结果映射到pojo对象中。resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。 12345678910111213141516171819202122&lt;!-- resultMap最终还是要将结果映射到pojo上，type就是指定映射到哪一个pojo --&gt;&lt;!-- id：设置ResultMap的id --&gt;&lt;resultMap type="order" id="orderResultMap"&gt; &lt;!-- 定义主键 ,非常重要。如果是多个字段,则定义多个id --&gt; &lt;!-- property：主键在pojo中的属性名 --&gt; &lt;!-- column：主键在数据库中的列名 --&gt; &lt;id property="id" column="id" /&gt; &lt;!-- 定义普通属性 --&gt; &lt;result property="userId" column="user_id" /&gt; &lt;result property="number" column="number" /&gt; &lt;result property="createtime" column="createtime" /&gt; &lt;result property="note" column="note" /&gt;&lt;/resultMap&gt;&lt;!-- 查询所有的订单数据 --&gt;&lt;select id="queryOrderAll" resultMap="orderResultMap"&gt; SELECT id, user_id, number, createtime, note FROM orders&lt;/select&gt; 动态SQLif123456789101112131415//if标签&lt;!-- 根据条件查询用户 --&gt;&lt;select id="queryUserByWhere" parameterType="user" resultType="user"&gt; SELECT id, username, birthday, sex, address FROM `user` WHERE 1=1 &lt;if test="sex != null and sex != ''"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test="username != null and username != ''"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt;&lt;/select&gt;//注意字符串类型的数据需要做不等于空字符串校验 where123456789101112131415//where标签&lt;!-- 根据条件查询用户 --&gt;&lt;select id="queryUserByWhere" parameterType="user" resultType="user"&gt; SELECT id, username, birthday, sex, address FROM `user`&lt;!-- where标签可以自动添加where，同时处理sql语句中第一个and关键字 --&gt; &lt;where&gt; &lt;if test="sex != null"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test="username != null and username != ''"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; choose - when1234567891011121314151617//choose 实现ifelse功能&lt;select id="listProduct" resultType="Product"&gt; SELECT * FROM product_ &lt;where&gt; &lt;choose&gt; &lt;when test="name != null"&gt; and name like concat('%',#&#123;name&#125;,'%') &lt;/when&gt; &lt;when test="price !=null and price != 0"&gt; and price &gt; #&#123;price&#125; &lt;/when&gt; &lt;otherwise&gt; and id &gt;1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; foreach1234567891011//foreach标签&lt;!-- foreach标签，进行遍历 --&gt;&lt;!-- collection：遍历的集合，这里是QueryVo的ids属性 --&gt;&lt;!-- item：遍历的项目，可以随便写，，但是和后面的#&#123;&#125;里面要一致 --&gt;&lt;!-- open：在前面添加的sql片段 --&gt;&lt;!-- close：在结尾处添加的sql片段 --&gt;&lt;!-- separator：指定遍历的元素之间使用的分隔符 --&gt;&lt;foreach collection="ids" item="item" open="id IN (" close=")" separator=","&gt; #&#123;item&#125;&lt;/foreach&gt; foreach标签用于数组遍历 collection=”array” foreach标签用于列表遍历 collection=”list” bind123456//bind标签就像是再做一次字符串拼接，方便后续使用&lt;select id="listProduct" resultType="Product"&gt; &lt;bind name="likename" value="'%' + name + '%'" /&gt; select * from product_ where name like #&#123;likename&#125;&lt;/select&gt; sql片段12345678//sql片段&lt;!-- 声明sql片段 --&gt;&lt;sql id="userFields"&gt; id, username, birthday, sex, address&lt;/sql&gt;&lt;!-- 使用include标签加载sql片段；refid是sql片段id --&gt; SELECT &lt;include refid="userFields" /&gt; FROM `user 关联查询一对一一. 使用resultType 使用resultType，创建新的pojo类，此pojo类中包括了订单信息和用户信息这样返回对象的时候，mybatis自动把用户信息也注入进来了 定义专门的pojo类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。 123456789101112131415161718192021222324252627282930313233343536373839//1. 创建新的pojo类 package ccut.rj.pojo;public class OrderUser extends Orders &#123; /** * */ private static final long serialVersionUID = 1L; private String username; private String address; @Override public String toString() &#123; return "OrderUser [username=" + username + ", address=" + address + "]"; &#125; &#125;//2. mapper.xml&lt;!-- 查询订单，同时包含用户数据 --&gt;&lt;select id="queryOrderUser" resultType="orderUser"&gt; SELECT o.id, o.user_id userId, o.number, o.createtime, o.note, u.username, u.address FROM `order` o LEFT JOIN `user` u ON o.user_id = u.id&lt;/select&gt;//3. mapper接口public List&lt;OrderUser&gt; queryOrderUser();//4. 单元测试List&lt;OrderUser&gt; list = userMapper.queryOrderUser(); 二. 使用resultMap 使用resultMap，定义专门的resultMap用于映射一对一查询结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//1. 改造orders的pojo// 附加对象 用户对象private User user;//2. mapper.xmlresultMap type="orders" id="orderUserResultMap"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="userId" column="user_id" /&gt; &lt;result property="number" column="number" /&gt; &lt;result property="createtime" column="createtime" /&gt; &lt;result property="note" column="note" /&gt; &lt;!-- association ：配置一对一属性 --&gt; &lt;!-- property:order里面的User属性名 --&gt; &lt;!-- javaType:属性类型 --&gt; &lt;association property="user" javaType="user"&gt; &lt;!-- id:声明主键，表示user_id是关联查询对象的唯一标识--&gt; &lt;id property="id" column="user_id" /&gt; &lt;result property="username" column="username" /&gt; &lt;result property="address" column="address" /&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- 一对一关联，查询订单，订单内部包含用户属性 --&gt;&lt;select id="queryOrderUserResultMap" resultMap="orderUserResultMap"&gt; SELECT o.id, o.user_id, o.number, o.createtime, o.note, u.username, u.address FROM `order` o LEFT JOIN `user` u ON o.user_id = u.id&lt;/select&gt;//3. mapper接口public List&lt;Orders&gt; queryOrderUserResultMap();//4. 单元测试List&lt;Orders&gt; list = userMapper.queryOrderUserResultMap(); 一对多 一端的pojo设置一个多端的pojo的列表 一端的xml映射文件中的resultMap中的collection设置多端的键值 resultMap 12345678910111213141516171819202122232425262728293031323334353637383940414243//1. 修改pojo Userprivate List&lt;Orders&gt; orders; //订单列表//2. mapper.xml&lt;resultMap type="user" id="userOrderResultMap"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="username" column="username" /&gt; &lt;result property="birthday" column="birthday" /&gt; &lt;result property="sex" column="sex" /&gt; &lt;result property="address" column="address" /&gt; &lt;!-- 配置一对多的关系 --&gt; &lt;collection property="orders" javaType="list" ofType="order"&gt; &lt;!-- 配置主键，是关联Order的唯一标识 --&gt; &lt;id property="id" column="oid" /&gt; &lt;result property="number" column="number" /&gt; &lt;result property="createtime" column="createtime" /&gt; &lt;result property="note" column="note" /&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 一对多关联，查询订单同时查询该用户下的订单 --&gt;&lt;select id="queryUserOrder" resultMap="userOrderResultMap"&gt; SELECT u.id, u.username, u.birthday, u.sex, u.address, o.id oid, o.number, o.createtime, o.note FROM `user` u LEFT JOIN `order` o ON u.id = o.user_id&lt;/select&gt;//3. mapper接口public List&lt;User&gt; queryUserOrder();//4. 测试List&lt;User&gt; list = userMapper.queryUserOrder(); 多对一 多端的pojo中设置一个一端的pojo对象 多端的xml映射文件中的resultMap进行字段和属性的对应。使用association 进行多对一关系关联，指定表字段名称与对象属性名称的一一对应关系 多对多 为了维系多对多关系，必须要一个中间表。 中间表的pojo中设置两个多端的pojo对象。 两个多端的xml映射文件一个设置为多对一的形式，一个为resultMap - collection - association的形式 123456789101112131415161718192021&lt;resultMap type="Order" id="orderBean"&gt; &lt;id column="oid" property="id" /&gt; &lt;result column="code" property="code" /&gt; &lt;collection property="orderItems" ofType="OrderItem"&gt; &lt;id column="oiid" property="id" /&gt; &lt;result column="number" property="number" /&gt; &lt;association property="product" javaType="Product"&gt; &lt;id column="pid" property="id"/&gt; &lt;result column="pname" property="name"/&gt; &lt;result column="price" property="price"/&gt; &lt;/association&gt; &lt;/collection&gt;&lt;/resultMap&gt;//联合order_, order_item_, product_ 三张表进行查询//查询结果 id和code字段放在Order对象里， 然后通过一对多的&lt;collectio&gt;标签把oiid和number放在OrderItem对象里，最后把pid,pname,price放进Product对象里。//删除关系，就是删除掉中间表的记录。//多对多不存在修改关系的做法，就是删除旧的，然后新增一条即达到修改的效果。 相关概念日志1. 导入log4j的jar包2. 新建log4j.properties 123456789//log4j.properties# Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...log4j.logger.com.how2java=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 事务管理1. JDBC方式 - environment下的\&lt;transactionManager type=”JDBC”/> 2. MYSQL 表的类型必须是INNODB 延迟加载在mybatis的配置文件中修改配置123456&lt;settings\&gt; &lt;!-- 打开延迟加载的开关 --&gt; &lt;setting name="lazyLoadingEnabled" value="true" /&gt; &lt;!-- 将积极加载改为消息加载即按需加载 --&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;/settings\&gt; 分页SQL中的limit 123456789101112131415//1. xml方式//XML文件&lt;select id="listByPage" resultType="Category"&gt; select * from category_ &lt;if test="start!=null and count!=null"&gt; limit #&#123;start&#125;,#&#123;count&#125; &lt;/if&gt;&lt;/select&gt;//接口public List&lt;Category&gt; listByPage(@Param("start") int start, @Param("count")int count);//测试List&lt;Category&gt; cs =mapper.listByPage(0, 5); 12345//2. 注解方式//接口@Select(" select * from category_ limit #&#123;start&#125;,#&#123;count&#125;")public List&lt;Category&gt; listByPage(@Param("start") int start, @Param("count")int count); PageHelperPageHelper是一款犀利的Mybatis分页插件 https://github.com/pagehelper/Mybatis-PageHelper 导入jar包 修改mybatis的配置xml文件 查询前加入PageHelper.offsetPage(0, 5); 查总数PageInfo pageInfo = new PageInfo\&lt;>(list); 配置文件加入1234&lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;/plugin&gt;&lt;/plugins&gt; 一级缓存（默认）在session1中查询两次id=1的Category对象。第一次会去数据库中取数据，但是第二次就不会访问数据库了，而是直接从session中取出来。 二级缓存（需开启）Mybatis二级缓存是SessionFactory，如果两次查询基于同一个SessionFactory，那么就从二级缓存中取数据，而不用到数据库里去取了。 1. mybatis配置文件开启二级缓存：&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 2. mapper的xml文件中启动对象的二级缓存：&lt;cache/&gt; 3. 对象需要实现序列化接口Serializable 查询总数@Select(“ select count(*) from category_ “) public int count(); SQL中关于count的对比count(1) and count(*)当表的数据量大些时，对表作分析之后，使用count(1)还要比使用count()用时多了！ 从执行计划来看，count(1)和count()的效果是一样的。 但是在表做过分析之后，count(1)会比count(*)的用时少些（1w以内数据量），不过差不了多少。 如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。 因为count(),自动会优化指定到那一个字段。所以没必要去count(1)，用count()，sql会帮你完成优化的 因此：count(1)和count(*)基本没有差别！ count(1) and count(字段) 两者的主要区别是 （1） count(1) 会统计表中的所有的记录数，包含字段为null 的记录。 （2） count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 count(*) 和 count(1)和count(列名)区别执行效果上： count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。 执行效率上： 列名为主键，count(列名)会比count(1)快 列名不为主键，count(1)会比count(列名)快 如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*） 如果有主键，则 select count（主键）的执行效率是最优的 如果表只有一个字段，则 select count（\）最优。** 备注这篇文章里大多使用的是XMl，day02会有Mybatis中注解的使用方式的介绍]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew - Mac包管理器]]></title>
    <url>%2F2019%2F05%2F12%2FHomebrew-Mac%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[介绍brew是一个软件包管理工具,类似于centos下的yum或者ubuntu下的apt-get,非常方便,免去了自己手动编译安装的不便 brew 安装目录 /usr/local/Cellar brew 配置目录 /usr/local/etc brew 命令目录 /usr/local/bin 注:homebrew在安装完成后自动在/usr/local/bin加个软连接，所以平常都是用这个路径 安装安装方法:ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Homebrew 镜像使用帮助 注:该镜像是 Homebrew 的 formula 索引的镜像（即 brew update 时所更新内容）。本镜像站同时提供 Homebrew 二进制预编译包的镜像，请参考 Homebrew bottles 镜像使用帮助。 替换现有上游1、替换homebrew默认源。 替换USTC镜像：12cd &quot;$(brew --repo)&quot;git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 重置为官方地址：12cd &quot;$(brew --repo)&quot;git remote set-url origin https://github.com/Homebrew/brew.git 2、替换homebrew-core默认源 替换 USTC 镜像：12cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 重置为官方地址：12cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://github.com/Homebrew/homebrew-core 3、替换homebrew-cask默认源 替换为 USTC 镜像：12cd &quot;$(brew --repo)&quot;/Library/Taps/homebrew/homebrew-caskgit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git 重置为官方地址：12cd &quot;$(brew --repo)&quot;/Library/Taps/homebrew/homebrew-caskgit remote set-url origin https://github.com/Homebrew/homebrew-cask 4、替换homebrew bottles 实际就是修改环境变量。我的mac默认是没有这个变量的，目前我也没用到homebrew bottle，不过看其他资料有声明这个变量的，方法是 对于 bash 用户：12echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profilesource ~/.bash_profile 对于 zsh 用户：12echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.zshrcsource ~/.zshrc]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>我的软件</tag>
        <tag>Mac OS</tag>
        <tag>Terminal</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pycharm for mac快捷键]]></title>
    <url>%2F2019%2F05%2F12%2FPycharm-for-mac%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[最好的Python IDE cmd b 跳转到声明处（cmd加鼠标） opt + 空格 显示符号代码 （esc退出窗口 回车进入代码） cmd []光标之前/后的位置 opt + F7 find usage cmd backspace 删除当前行 cmd +c 复制光标当前行,剪切同理 cmd + f 当前文件搜索（回车下一个 shift回车上一个） cmd + r 当前文件替换 shift + cmd + f 全局搜索 shift + cmd + R 全局替换 cmd+o 搜索class shift + cmd + o 搜索文件 opt + cmd + o 搜索符号（函数等) cmd + l 指定行数跳转 shift enter 在行中的时候直接到下一行 cmd + 展开当前 cmd - 折叠当前 shift cmd + 展开所有 shift cmd - 折叠所有 cmd / 注释/取消注释一行 opt + cmd + / 批量注释(pycharm不生效) ctr + tab 史上最NB的导航窗口（工程文件列表、文件结构列表、命令行模式、代码检查、VCS等，下面两个是可以被替换的） alt + F12 打开命令行栏 cmd + F12 显示文件结构 cmd j 代码智能补全 alt + F1 定位编辑文件所在位置: cmd + F6 更改变量 opt + cmd + t 指定代码被注释语句或者逻辑结构、函数包围 Tab / Shift + Tab 缩进、不缩进当前行 opt + cmd + l 代码块对齐 cmd+d 在下一行复制本行的内容]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>我的软件</tag>
        <tag>Python</tag>
        <tag>Mac OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda的使用]]></title>
    <url>%2F2019%2F05%2F12%2FAnaconda%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[工具包的安装删除conda install [package_name] conda insatll -n [your_env] [package_name] coada remove [package_name] conda remove -n [your_env] [package_name] 查看环境conda list #查看安装了那些package conda list –name [your_env] #查看指定环境下的package conda env list / conda info -e #查看当前存在的虚拟环境 conda env –help #查看帮助 创建python虚拟环境conda create -n/–name [your_env] [python=2.7] [package_name] 克隆 conda create –name [虚拟环境名] – clone [colne的环境] 创建一个和原python环境一样的虚拟环境 conda create –name [your_base] –clone base #your_env文件可以在Anaconda安装目录envs文件下找到。 删除虚拟环境conda remove -n [your_env] –all conda remove –name [your_env] [package_name] 激活虚拟环境source activate [your_env] #每次使用前要先切换到自己的环境中 关闭虚拟环境source deactivate 更新conda update conda conda update anaconda conda update python conda update -n [python] [package_name] 添加国内镜像# 添加Anaconda的TUNA镜像 conda config –add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ # TUNA的help中镜像地址加有引号，需要去掉 设置搜索时显示通道地址conda config –set show_channel_urls yes PackageNotFoundError1.conda install package_name 2.anaconda search -t conda package_name 3.anaconda show &lt;USER/PACKAGE&gt; 4.conda install –channel &lt;package_name&gt; conda install package_name 如果找不到这个工具包 PackageNotFoundError: Packages missing in current channels: - wordcloudWe have searched for the packages in the following channels:‘’ - https://repo.continuum.io/pkgs/main/linux-64‘’ - https://repo.continuum.io/pkgs/main/noarch‘’ - https://repo.continuum.io/pkgs/free/linux-64‘’ - https://repo.continuum.io/pkgs/free/noarch‘’ - https://repo.continuum.io/pkgs/r/linux-64‘’ - https://repo.continuum.io/pkgs/r/noarch‘’ - https://repo.continuum.io/pkgs/pro/linux-64‘’ - https://repo.continuum.io/pkgs/pro/noarch 以wordcould为例：$anaconda search -t conda wordclould(python36) C:\Users\zbb>anaconda search -t conda wordcloudUsing Anaconda API: https://api.anaconda.orgPackages: Name | Version | Package Types | Platforms | Builds Found 8 packages Run ‘anaconda show \&lt;USER/PACKAGE>‘ to get installation details‘’$anaconda show conda-forge/wordcloud(python36) C:\Users\zbb>anaconda show conda-forge/wordcloud Using Anaconda API: https://api.anaconda.org Name: wordcloud Summary: A little word cloud generator in Python Access: public Package Types: conda Versions: 1.2.1 1.3.3 1.4 1.4.1 To install this package with conda run:conda install –channel https://conda.anaconda.org/conda-forge wordcloud $conda install –channel https://conda.anaconda.org/conda-forge wordcloud]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>我的软件</tag>
        <tag>Python</tag>
        <tag>Mac OS</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解MVC设计模式]]></title>
    <url>%2F2019%2F05%2F12%2F%E8%AF%A6%E8%A7%A3MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式 - MVCMVC介绍M 代表 模型（Model）V 代表 视图（View）C 代表 控制器（controller) 众所周知MVC不是设计模式，是一个比设计模式更大一点的模式，称作设计模式不合理，应该说MVC它是一种软件开发架构模式，它包含了很多的设计模式，最为密切是以下三种：Observer (观察者模式), Composite（组合模式）和Strategy（策略模式）。所以说MVC模式又称复合模式。MVC(Model-View-Controller) 模式的基本思想是数据，显示和处理相分离。模型(Model)负责数据管理，视图(View)负责数据显示，控制器(Controller)负责业务逻辑和响应策略。 从MVC的形成过程来看，最初只有模型和视图两个元素。模型封装了数据并提供操作接口，视图用来表现数据和接收用户请求。模型是独立的，而视图依赖于模型：从模型获取数据进行显示；向模型发送用户请求，并根据返回结果刷新自己。 需要用多个视图表现同一模型时，情况发生了变化：一个视图修改数据以后，不但本身要刷新，其他所有视图也要刷新。如果由该视图通知其他视图，它就需要知道其他所有视图，由于每个视图都可能发出修改，每个视图都要知道其他所有视图，这种关联过于复杂，不但难以维护，而且不便于增加新的视图。如果让模型通知所有视图更新，可能会影响模型的独立性。用观察者(Observer)模式 可以解决上述矛盾，从而实现：由模型通知视图，而模型不依赖于具体的视图，具体视图之间相互独立。 视图是用户请求的接收者，但不宜作为请求的处理者。因为界面是易变的，如果业务代码和界面代码放在一起，频繁的界面修改可能会破坏比较稳定的业务代码。将业务逻辑分离出来，由一个控制器负责，就是为了避免这种干扰。 模型在状态变化的时候，直接通知所有视图，视图向模型查询状态数据，然后刷新自身。当用户发出操作时，视图把消息发给控制器，控制器按照业务逻辑进行处理，需要查询或更新数据时，控制器会调用模型。 MVC架构把数据处理，程序输入输出控制及数据显示分离开来，并且描述了不同部件的对象间的通信方式。使得软件可维护性，可扩展性，灵活性以及封装性大大提高；MVC(Model-View-Controller)把系统的组成分解为M（模型）、 V（视图）、C（控制器）三种部件。视图表示数据在屏幕上的显示。控制器提供处理过程控制，它在模型和视图之间起连接作用。控制器本身不输出任何信息和做任何处理，它只负责把用户的请求转成针对Model的操作，和调用相应的视图来显示Model处理后的数据。 同样的数据，可以有不同的显示和进行各种处理。显示仅仅是表现数据，而处理是根据用户请求改变数据的过程，不但包含业务逻辑，也要提供响应策略。响应策略由控制器负责，视图可以使用不同的控制器提供不同的响应方式，这是策略(Strategy)模式的应用。 此外，MVC还允许视图嵌套，通过使用组合(Composite)模式，一致地处理组合视图和普通视图。 用多个视图表现一个模型，在视图不变的情况下改变响应策略，允许视图嵌套，这是MVC的三个主要特性。在内部结构上，MVC的主要关系是由观察者模式，策略模式和组合模式给出的。由观察者模式确定的模型视图关系是其中最为重要的。 MVC 模式有许多变体。前述结构中，由模型通知视图刷新，称为主动MVC；如果由控制器更新模型以后通知视图，称为被动MVC结构。在许多应用中，没有明显的控制器角色，也没有视图嵌套。可见根据实际需要，构成MVC的三个模式上都可能出现变化。Web浏览器就是被动MVC结构的一个实例。 “ 浏览器是一个交互程序，从概念上讲，它是由一组客户、一组解释器与一个管理它们的控制器所组成。控制器形成了浏览器的中心部件，它解释鼠标点击与键盘输入，并且调用其他组件来执行用户指定的操作。例如，当用户键入一个URL或者点击一个超文本引用时，控制器调用一个客户从所需文档所在的远程服务器上取回该文档，并且调用解释器向用户显示该文档。每个浏览器必须包含一个HTML解释器来显示文档，其他解释器是可选的。HTML解释器的输入由符合HTML语法的文档所组成，输出由位于用户显示器上的格式版本文档所组成。解释器通过将HTML规则转换成适合用户显示硬件的命令来处理版面细节。HTML解释器一个最重要的功能是包含可选项。解释器必须存储关于显示器上位置之间关系的信息和HTML文档中被瞄定的项。当用户用鼠标选定了一个项，浏览器通过当前的光标位置和存储的位置信息来决定哪个项被用户选定。” 为什么要在Web应用中使用MVC架构用户界面逻辑的更改往往比业务逻辑频繁，尤其是在基于Web的应用程序中。例如，可能添加新的用户界面页，或者可能完全打乱现有的页面布局。对显示的更改，尽可能地不要影响到数据和业务逻辑。 目前大部分Web应用都是将数据代码和表示混在一起。经验比较丰富的开发者会将数据从表示层分离开来，但这通常不是很容易做到的，它需要精心的计划和不断的尝试。MVC从根本上强制性的将它们分开。尽管构造MVC应用需要一些额外的工作，但它带来的好处是无庸质疑的 提高代码重用率最重要的一点是多个视图能共享一个模型，无论用户想要Flash界面或是 WAP 界面；用一个模型就能处理它们。由于已经将数据和业务规则从表示层分开，所以可以最大化的重用代码。 提高程序的可维护性因为模型是自包含的，并且与控制器和视图相分离，所以很容易改变数据层和业务规则 [3]。例如，把数据库从MySQL移植到Oracle，或者把基于RDBMS数据源改变到LDAP，只需改变模型即可。一旦正确的实现了模型，不管数据来自哪里，视图都会正确的显示它们。MVC架构的运用，使得程序的三个部件相互对立，大大提高了程序的可维护性。 有利于团队开发在开发过程中，可以更好的分工，更好的协作。有利于开发出高质量的软件。良好的项 目架构设计，将减少编码工作量 ：采用MVC结构 + 代码生成器，是大多数Web应用的理想选择。部分模型(Model)、和存储过程一般可用工具自动生成。控制(Controller)器比较稳定，一般由于架构师（也可能是有经验的人）完成；那么整个项目需要手动编写代码的地方就只有视图(View)了。在这种模式下，个人能力不在特别重要，只要懂点语法基础的人都可以编写，无论项目成员写出什么样的代码，都在项目管理者的可控范围内。即使项目中途换人，也不会有太大问题。在个人能力参差不齐的团队开发中，采用MVC开发是非常理想的。 MVC架构的优点及不足MVC的优点MVC的优点体现在以下几个方面： （1） 有利于团队开发分工协作和质量控制，降低开发成本。 （2） 可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步。 （3） 视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换。 （4） 模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的修改。 （5） 潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中。 MVC的缺点MVC的不足体现在以下几个方面： （1）增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 （2）视图对模型数据的访问效率低。视图可能需要多次调用Model才能获得足够的显示数据。 （3）完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。同时由于模型和视图要严格的分离，这样也给调试应用程序到来了一定的困难。 MVC 模式可以分解为以下设计模式在GOF书的 Introduction中，有一小节是”Design Patterns in Smalltalk MVC”即介绍在MVC模式里用到的设计模式。它大概向我们传达了这样的信息：合成模式+策略模式+观察者模式约等于MVC模式（当然MVC模式要多一些东西）。也就是说它在大部分情况下是下面几个模式： (1)、观察者模式 (2)、合成模式 (3)、策略模式 谈谈MVC 架构模式中的三个角色 Model （模型端） Mod封装的是数据源和所有基于对这些数据的操作。在一个组件中，Model往往表示组件的状态和操作这些状态的方法，往往是一系列的公开方法。通过这些公开方法，便可以取得模型端的所有功能。 在这些公开方法中，有些是取值方法，让系统其他部分可以得到模型端的内部状态参数，其他的改值方法则允许外部修改模型端的内部状态。模型端还必须有方法登记视图，以便在模型端的内部状态发生变化时，可以通知视图端。我们可以自己定义一个Subject接口来提供登记和通知视图所需的接口或者继承 Java.util.Observable类，让父类完成这件事。 多个 View( 视图端 ) View封装的是对数据源Model的一种显示。一个模型可以由多个视图，并且可以在需要的时候动态地登记上所需的视图。而一个视图理论上也可以同不同的模型关联起来。 在前言里提到了，MVC模式用到了合成模式，这是因为在视图端里，视图可以嵌套，比如说在一个JFrame组件里面，可以有菜单组件，很多按钮组件等。 多个 Controller( 控制器端 ) 封装的是外界作用于模型的操作。通常，这些操作会转发到模型上，并调用模型中相应的一个或者多个方法（这个方法就是前面在介绍模型的时候说的改值方法）。一般Controller在Model和View之间起到了沟通的作用，处理用户在View上的输入，并转发给Model来更改其状态值。这样 Model和View两者之间可以做到松散耦合，甚至可以彼此不知道对方，而由Controller连接起这两个部分。也在前言里提到，MVC用到了策略模式，这是因为View用一个特定的Controller的实例来实现一个特定的响应策略，更换不同的Controller，可以改变View对用户输入的响应。 MVC (Model-View-Controller) : 模型利用”观察者”让控制器和视图可以随最新的状态改变而更新。另一方面，视图和控制器则实现了”策略模式”。控制器是视图的行为; 视图内部使用”组合模”式来管理显示组件。 以下的MVC解释图很好的标示了这种模式： 模型使用观察者模式，以便观察者更新，同时保持两者之间的解耦。 控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为。 视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，像面板、框架和按钮。 这些模式携手合作，把MVC模式的三层解耦，这样可以保持设计干净又有弹性。]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA for Mac 快捷键]]></title>
    <url>%2F2019%2F05%2F12%2FIntelliJ%20IDEA%20For%20Mac%20%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[9102年了，该使用现代IDE了，放弃Eclipse吧 command + click/ command + B 查看源码 control + H 查看类的层次结构 command + shift + H 查看方法的层次结构 control + option + H 查看调用的层次结构 command + Fn + F12 查看当前类的所有方法 shift option command U 查看当前类的继承关系图 command + P 显示方法的参数信息 command + N 查找类 command + shift + N 查找文件 command + F 当前文件查找文本 command + shift + F 全局查找文本 command + R 当前文件替换文本 command + shift + R 全局替换文本 control + O 重写方法 control + I 实现方法 control + N 构造器/setter&amp;&amp;getter/hashcode/equals/toString option + 回车 导入包，自动修正 command + space 代码提示 command + shift + space 自动代码补全 option + 回车 显示意向动作和快速修复代码 command + / 注释/取消注释 command + option + L 格式化代码 control + option + O 优化import contorl + option + I 自动缩进线 ⇥ / ⇧⇥ 缩进代码 / 反缩进代码 command + &quot;+&quot;/ command + &quot;-&quot; 展开/折叠代码块 command + shift + &quot;+&quot; / command + shift + &quot;-&quot; 展开/折叠所有代码块 control + R 运行 control + D 调试 F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 command + option + R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 command + shift + F8 查看断点信息]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>我的软件</tag>
        <tag>Mac OS</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Spring - day1]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%AD%A6%E4%B9%A0Spring-day1%2F</url>
    <content type="text"><![CDATA[Spring框架概述介绍Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。 核心 IOC Inversion of Control 控制反转 DI Dependency Injection 依赖注入 AOP Aspect Oriented Programming 面向切面编程 优点 高内聚低耦合 支持AOP编程 支持声明式事务 方便程序测试 方便集成其他框架 降低JavaEE API的使用难度 体系结构 核心容器：beans core context expression(SpEL) IOC实例IoC Inverse of Control, 控制反转 好莱坞法则：“别找我们，我们找你”即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 导入jar包commons-loggingspring-beansspring-contextspring-corespring-expression 配置文件（xml）123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean name="a" class="com.rj.spring.test.UserImp"&gt;&lt;/bean&gt;&lt;/beans&gt; 目标类12345678910public interface User &#123; public void sayHello();&#125;public class UserImp implements User &#123; @Override public void sayHello() &#123; System.out.println("Hello World!"); &#125;&#125; 测试类1234567891011121314import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring &#123; @Test public void demo1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("com/rj/spring/test/MySpring.xml"); User user = (User)applicationContext.getBean("a"); user.sayHello(); &#125;&#125; DI 实例DI Dependency Injection ,依赖注入 is a ：是一个，继承。 has a：有一个，成员变量，依赖。 class B { private A a; //B类依赖A类 } 依赖：一个对象需要使用另一个对象 注入：通过setter方法进行另一个对象实例设置。 创建目标类User Phone接口和UserImp和PhoneImp实现类 12345678910111213141516171819202122232425262728public interface User &#123; public void sayHello();&#125;public interface Phone &#123; public void say();&#125;public class UserImp implements User &#123; private PhoneImp phone; @Override public void sayHello() &#123; phone.say(); &#125; public void setPhone(PhoneImp phone) &#123; this.phone = phone; &#125;&#125;public class PhoneImp implements Phone &#123; @Override public void say() &#123; System.out.println("I'm a SMARTISAN"); &#125;&#125; 配置文件12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean name="a" class="com.rj.spring.test.UserImp"&gt; &lt;property name="phone" ref="phoneNum"/&gt; &lt;/bean&gt; &lt;bean name="phoneNum" class="com.rj.spring.test.PhoneImp"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试方法1234567@Testpublic void demo2()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("com/rj/spring/test/MySpring.xml"); User user = (User)applicationContext.getBean("a"); user.sayHello();&#125; 核心APIBeanFactory ：这是一个工厂，用于生成任意bean。采取延迟加载，第一次getBean时才会初始化Bean ApplicationContext：是BeanFactory的子接口，功能更强大。（国际化处理、事件传递、Bean自动装配、各种不同应用层的Context实现）。当配置文件被加载，就进行对象实例化。 ClassPathXmlApplicationContext 用于加载classpath（类路径、src）下的xml 加载xml运行时位置 –> /WEB-INF/classes/…xml FileSystemXmlApplicationContext 用于加载指定盘符下的xml 加载xml运行时位置 –> /WEB-INF/…xml 通过java web ServletContext.getRealPath() 获得具体盘符 装配Bean基于XML实例化方法默认构造 //必须提供默认构造 静态工厂常用与spring整合其他框架（工具）静态工厂：用于生成实例对象，所有的方法必须是static 123456789101112//工厂public class MyBeanFactory &#123; public static UserService createService()&#123; return new UserServiceImpl(); &#125;&#125;//配置文件&lt;!-- 将静态工厂创建的实例交予spring class 确定静态工厂全限定类名 factory-method 确定静态方法名 --&gt;&lt;bean id="userServiceId" class="com.MyBeanFactory" factory-method="createService"&gt;&lt;/bean&gt; 实例工厂实例工厂：必须先有工厂实例对象，通过实例对象创建对象。提供所有的方法都是“非静态”的 1234567891011121314151617//实例工厂,所有方法非静态public class MyBeanFactory &#123; public UserService createService()&#123; return new UserServiceImpl(); &#125;&#125; //spring配置&lt;!-- 创建工厂实例 --&gt;&lt;bean id="myBeanFactoryId" class="com.itheima.c_inject.c_factory.MyBeanFactory"&gt;&lt;/bean&gt;&lt;!-- 获得userservice* factory-bean 确定工厂实例* factory-method 确定普通方法--&gt;&lt;bean id="userServiceId" factory-bean="myBeanFactoryId" factory-method="createService"&gt;&lt;/bean&gt; Bean种类 普通bean：之前操作的都是普通bean。 ，spring直接创建A实例，并返回 FactoryBean：是一个特殊的bean，具有工厂生成对象能力，只能生成特定的对象。 bean必须使用 FactoryBean接口，此接口提供方法 getObject() 用于获得特定bean。 先创建FB实例，使用调用getObject()方法，并返回方法的返回值FB fb = new FB(); return fb.getObject(); BeanFactory 和 FactoryBean 对比？ BeanFactory：工厂，用于生成任意bean。 FactoryBean：特殊bean，用于生成另一个特定的bean。例如：ProxyFactoryBean ，此工厂bean用于生产代理。 获得代理对象实例。AOP使用 作用域 作用域：用于确定spring创建bean实例个数 取值：singleton 单例，默认值。prototype 多例，每执行一次getBean将获得一个实例。例如：struts整合spring，配置action多例。 配置信息 生命周期初始化和销毁目标方法执行前后执行后，将进行初始化或销毁。 实例123456789101112131415161718192021222324252627282930313233343536373839404142//目标类public class UserServiceImpl implements UserService &#123; public void addUser() &#123; System.out.println("e_lifecycle add user"); &#125; public void myInit()&#123; System.out.println("初始化"); &#125; public void myDestroy()&#123; System.out.println("销毁"); &#125;&#125;//spring配置&lt;!-- init-method 用于配置初始化方法,准备数据等 destroy-method 用于配置销毁方法,清理资源等--&gt;&lt;bean id="userServiceId" class="com.UserServiceImpl" init-method="myInit" destroy-method="myDestroy" &gt;&lt;/bean&gt; //测试方法@Testpublic void demo02() throws Exception&#123; //spring 工厂 String xmlPath = "com/beans.xml"; ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); UserService userService = (UserService) applicationContext.getBean("userServiceId"); userService.addUser(); //要求：1.容器必须close，销毁方法执行; 2.必须是单例的 //applicationContext.getClass().getMethod("close").invoke(applicationContext); // * 此方法接口中没有定义，实现类提供 applicationContext.close();&#125; BeanPostProcessor后处理Bean spring 提供一种机制，只要实现此接口BeanPostProcessor，并将实现类提供给spring容器，spring容器将自动执行，在初始化方法前执行before()，在初始化方法后执行after() 。 配置 Factory hook(勾子) that allows for custom modification of new bean instances, e.g. checking for marker interfaces or wrapping them with proxies. spring提供工厂勾子，用于修改实例对象，可以生成代理对象，是AOP底层。 实现1234567891011121314151617181920212223242526272829303132//实现类public class MyBeanPostProcessor implements BeanPostProcessor &#123; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("前方法 ： " + beanName); return bean; &#125; public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException &#123; System.out.println("后方法 ： " + beanName); // bean 目标对象 // 生成 jdk 代理 return Proxy.newProxyInstance( MyBeanPostProcessor.class.getClassLoader(), bean.getClass().getInterfaces(), new InvocationHandler()&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("------开启事务"); //执行目标方法 Object obj = method.invoke(bean, args); System.out.println("------提交事务"); return obj; &#125;&#125;); &#125;&#125; //配置&lt;!-- 将后处理的实现类注册给spring --&gt; &lt;bean class="com.MyBeanPostProcessor"&gt;&lt;/bean&gt; 属性依赖注入 依赖注入方式：手动装配 和 自动装配 手动装配：一般进行配置信息都采用手动 基于xml装配：构造方法、setter方法 基于注解装配： 自动装配：struts和spring 整合可以自动装配 byType：按类型装配 byName：按名称装配 constructor构造装配， auto： 不确定装配。 构造方法123456789101112131415161718192021222324252627282930313233343536373839//目标类public class User &#123; private Integer uid; private String username; private Integer age; public User(Integer uid, String username) &#123; super(); this.uid = uid; this.username = username; &#125; public User(String username, Integer age) &#123; super(); this.username = username; this.age = age; &#125; //spring配置 &lt;!-- 构造方法注入 * &lt;constructor-arg&gt; 用于配置构造方法一个参数argument name ：参数的名称 value：设置普通数据 ref：引用数据，一般是另一个bean id值 index ：参数的索引号，从0开始 。如果只有索引，匹配到了多个构造方法时，默认使用第一个。 type ：确定参数类型 例如：使用名称name &lt;constructor-arg name="username" value="jack"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt; 例如2：【类型type 和 索引 index】 &lt;constructor-arg index="0" type="java.lang.String" value="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" type="java.lang.Integer" value="2"&gt;&lt;/constructor-arg&gt; --&gt; &lt;bean id="userId" class="com.User" &gt; &lt;constructor-arg index="0" type="java.lang.String" value="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" type="java.lang.Integer" value="2"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; setter方法12345678910111213&lt;!-- setter方法注入 * 普通数据 &lt;property name="" value="值"&gt; 等效 &lt;property name=""&gt; &lt;value&gt;值 * 引用数据 &lt;property name="" ref="另一个bean"&gt; 等效 &lt;property name=""&gt; &lt;ref bean="另一个bean"/&gt; --&gt; P命令空间 对“setter方法注入”进行简化，替换，而是在 p命名空间使用前提，必须添加命名空间 123456789101112&lt;bean id="personId" class="com.Person" p:pname="aa" p:age="22" p:homeAddr-ref="homeAddrId" p:companyAddr-ref="companyAddrId"&gt;&lt;/bean&gt;&lt;bean id="homeAddrId" class=".Address" p:addr="DG" p:tel="beijing"&gt;&lt;/bean&gt;&lt;bean id="companyAddrId" class="com..Address" p:addr="DG" p:tel="china"&gt;&lt;/bean&gt; SpEL 对进行统一编程，所有的内容都使用value #{123}、#{‘jack’} ： 数字、字符串 #{beanId} ：另一个bean引用 #{beanId.propName} ：操作数据 #{beanId.toString()} ：执行方法 #{T(类).字段|方法} ：静态方法或字段 1234567891011&lt;!-- &lt;property name="cname" value="#&#123;'jack'&#125;"&gt;&lt;/property&gt; &lt;property name="cname" value="#&#123;customerId.cname.toUpperCase()&#125;"&gt;&lt;/property&gt; 通过另一个bean，获得属性，调用的方法 &lt;property name="cname" value="#&#123;customerId.cname?.toUpperCase()&#125;"&gt;&lt;/property&gt; ?. 如果对象不为null，将调用方法 --&gt;&lt;bean id="customerId" class="com.Customer" &gt; &lt;property name="cname" value="#&#123;customerId.cname?.toUpperCase()&#125;"&gt;&lt;/property&gt; &lt;property name="pi" value="#&#123;T(java.lang.Math).PI&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 集合注入1234567891011&lt;!-- 集合的注入都是给&lt;property&gt;添加子标签 数组：&lt;array&gt; List：&lt;list&gt; Set：&lt;set&gt; Map：&lt;map&gt; ，map存放k/v 键值对，使用&lt;entry&gt;描述 Properties：&lt;props&gt; &lt;prop key=""&gt;&lt;/prop&gt; 【】 普通数据：&lt;value&gt; 引用数据：&lt;ref&gt; --&gt; 装配Bean基于注解 注解：就是一个类，使用@注解名称 开发中：使用注解 取代 xml配置文件。 @Component取代@Component(&quot;id&quot;) 取代 &lt;bean id=&quot;&quot; class=&quot;&quot;&gt; web开发，提供3个@Component注解衍生注解（功能一样）取代@Repository ：dao层 @Service：service层 @Controller：web层 依赖注入，给私有字段设置，也可以给setter方法设置普通值：@Value(&quot;&quot;) 引用值： 方式1：按照【类型】注入 @Autowired 方式2：按照【名称】注入1 @Autowired @Qualifier(&quot;名称&quot;) 方式3：按照【名称】注入2 @Resource(&quot;名称&quot;) 生命周期初始化：@PostConstruct 销毁：@PreDestroy 作用域@Scope(&quot;prototype&quot;) 多例 注解使用前提，添加命名空间，让spring扫描含有注解类 实例12345678910&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 组件扫描，扫描含有注解的类 --&gt; &lt;context:component-scan base-package="com.a_ioc"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; scheme命令空间命令空间声明默认 xmlns=”” &lt;标签名&gt; –&gt; 显示 xmlns:别名=”” &lt;别名：标签名&gt; –&gt; &lt;context: …&gt; 确定scheme xsd文件位置xsi:schemaLocation=”名称 位置 名称2 位置2 。。。”内容成对出现「名称 位置」 Controller -&gt; Serice -&gt; Dao 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//配置文件&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 组件扫描，扫描含有注解的类 --&gt; &lt;context:component-scan base-package="com.rj.spring.test"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;//Controller层package com.rj.spring.test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controller("UserControllerId")public class UserController &#123; @Autowired private UserService userService; public void addUser() &#123; System.out.println("I'm a Controller!!!"); userService.addUserService(); &#125;&#125;//Serive层package com.rj.spring.test;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class UserService &#123; private UserDao userDao; @Resource(name = "UserDaoId") public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void addUserService() &#123; System.out.println("I find a Service!!!"); userDao.addUserDao(); &#125;&#125;//Dao层package com.rj.spring.test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controller("UserControllerId")public class UserController &#123; @Autowired private UserService userService; public void addUser() &#123; System.out.println("I'm a Controller!!!"); userService.addUserService(); &#125;&#125;//Test类package com.rj.spring.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestAnnoIoc &#123; @Test public void demo1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("com/rj/spring/test/MySpring.xml"); UserController userController = (UserController) applicationContext.getBean("UserControllerId"); userController.addUser(); &#125;&#125; 注解和XML混用1.将所有的bean都配置xml中1&lt;bean id="" class=""&gt; 2.将所有的依赖都使用注解 @Autowired 默认不生效。为了生效，需要在xml配置：1&lt;context:annotation-config&gt; 总结：注解1：1&lt;context:component-scan base-package=" "&gt; 注解2：1&lt;context:annotation-config&gt; 1.一般情况两个注解不一起使用。2.“注解1”扫描含有注解（@Component 等）类，注入注解自动生效。“注解2”只在xml和注解（注入）混合使用时，使注入注解生效。]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架中各层级间的作用及关系]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%85%B3%E4%BA%8ESSM%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[表现层（springMVC）：Controller层（Handler层）负责具体的业务模块流程的控制 Controller层通过要调用Service层的接口来控制业务流程，控制的 配置也在Spring配置文件里面。 业务层（Spring）：Service层负责业务模块的逻辑应用设计。 首先设计其接口，然后再实现他的实现类。 通过对Spring配置文件中配置其实现的关联，完成此步工作，我们 就可以通过调用Service的接口来进行业务处理。 最后通过调用DAO层已定义的接口，去实现Service具体的 实现类。 持久层（Mybatis）：Dao层（Mapper层）Dao层：负责与数据库进行交互设计，用来处理数据的持久化工作。 DAO层的设计首先是设计DAO的接口， 然后在Spring的配置文件中定义此接口的实现类，就可在其他模块中 调用此接口来进行数据业务的处理，而不用关心接口的具体实现类是 哪个类，这里用到的就是反射机制， DAO层的数据源配置，以及有 关数据库连接的参数都在Spring的配置文件中进行配置。 视图层：View层负责前台jsp页面的展示。 此层需要与Controller层结合起来开发。 各层间的联系：本来Controller层与View层是可以放在.jsp文件里一起开发的，但是为了降低代码的复杂度，提高其可维护性，将其分为了这两层，这也体现了MVC框架的特性，即结构清晰，耦合度低。 Service层是建立在DAO层之上的，建立了DAO层后才可以建立Service层，而Service层又是在Controller层之下的，因而Service层应该既调用DAO层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Mybatis</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>框架整合</tag>
      </tags>
  </entry>
</search>
